[{
	"id": "5d5cbb25421846662d983a25",
	"author_id": "5d5104cc697873456c6bca69",
	"tab": "share",
	"content": "<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/FmgpGBgp5Uiis4mzjJO6Ml80BYBM\" alt=\"众测 Banner 01.png\"></p>\n<p><strong>Nebulan Graph 捉虫计划</strong> 是开源的分布式图数据库 —— Nebula 发起的「找 Bug」活动，旨在发动开源社区的力量共建图数据库 Nebula。</p>\n<blockquote>\n<p><a href=\"https://strace.co/r/cnode\">Nebula Graph</a>：一个开源的分布式图数据库。作为唯一能够存储万亿个带属性的节点和边的在线图数据库，Nebula Graph 不仅能够在高并发场景下满足毫秒级的低时延查询要求，还能够实现服务高可用且保障数据安全性。</p>\n</blockquote>\n<h3>🙋 如何参与捉虫</h3>\n<h4>提 issue</h4>\n<p>阅读 Nebula Graph 文档或 Clone 代码运行，发现当中存在文档错误、运行错误前往 Nebula Graph 的 GitHub 提 issue 或在 Nebula Graph 交流群里提交 issue 即可。</p>\n<h4>提 pr</h4>\n<p>优秀如你发现了一个 Bug，顺手修复该 Bug，欢迎前往 Nebula Graph 的 GitHub 提 pr。</p>\n<h3>✊什么是捉虫奖励</h3>\n<p>Nebula Graph 官方将会对提交的 issue &amp; pr 进行定级，每个级别的 issue 和 pr 有对应的积分，积分可累计兑换对应的奖品。</p>\n<p>*说明：如遇到类似 issue 或 pr 先提交者获得积分，后者将不会得到积分。</p>\n<h4>issue &amp; pr 等级</h4>\n<table>\n<thead>\n<tr>\n<th>等级</th>\n<th>等级说明</th>\n<th>对应积分</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0 级</td>\n<td>发现并修复一个 P1 的 Bug</td>\n<td>100 个积分</td>\n</tr>\n<tr>\n<td>1 级</td>\n<td>发现并修复一个 P2 的 Bug</td>\n<td>50 个积分</td>\n</tr>\n<tr>\n<td>2 级</td>\n<td>提交一个 pr 并被接受（代码）</td>\n<td>30 个积分</td>\n</tr>\n<tr>\n<td>3 级</td>\n<td>发现一个 P1 Bug（服务 Crash或者数据丢失）</td>\n<td>10 个积分</td>\n</tr>\n<tr>\n<td>4 级</td>\n<td>发现一个 P2 Bug（未正确返回结果，或者严重文档错误）或提交一个文档 pr 并接受</td>\n<td>3 个积分</td>\n</tr>\n<tr>\n<td>5 级</td>\n<td>发现一个 P3 Bug（其他不严重的 Bug），或者提出一个 issue 被接受</td>\n<td>1 个积分</td>\n</tr>\n</tbody>\n</table>\n<h4>积分对应奖励</h4>\n<table>\n<thead>\n<tr>\n<th>积分</th>\n<th>物品&amp;数量</th>\n<th>积分</th>\n<th>物品&amp;数量</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>250 个积分</td>\n<td>AirPods *2</td>\n<td>205 个积分</td>\n<td>KindlePaper White *2</td>\n</tr>\n<tr>\n<td>200 个积分</td>\n<td>Filco 侧刻键盘 *2</td>\n<td>100 个积分</td>\n<td>IKBC 樱桃轴键盘 / 树莓派 4B*10</td>\n</tr>\n<tr>\n<td>90 个积分</td>\n<td>苹果 magic 2 代鼠标 *5</td>\n<td>80 个积分</td>\n<td>索尼小音箱 *5</td>\n</tr>\n<tr>\n<td>10 个积分</td>\n<td>¥100 京东E卡 / ¥100 星巴克券 / 小米无线充电器 *15</td>\n<td>8 个积分</td>\n<td>GitHub 帽 / GitHub 背包 / GitHub T恤 / 404 帽 *40</td>\n</tr>\n<tr>\n<td>7 个积分</td>\n<td>诺西N3 笔记本铝合金支架 *10</td>\n<td>5 个积分</td>\n<td>淘宝心选 U型枕 *20</td>\n</tr>\n<tr>\n<td>3 个积分</td>\n<td>GitHub 帆布袋 / GitHub 贴纸一套 *40</td>\n<td>2 个积分</td>\n<td>减压大 Enter 键 / ¥ 20 话费 *75</td>\n</tr>\n<tr>\n<td>1 个积分</td>\n<td>调试神器——小鸭子 / GitHub 贴纸一张（不单发）/ 胸章 *250</td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h4>奖品一览</h4>\n<p><img src=\"//static.cnodejs.org/Fj6PZJWf97M5H-XW3Ll_Nzl4lXTk\" alt=\"1 12.51.35.jpeg\">\n<img src=\"//static.cnodejs.org/FhUuIfocVAkwN20Mf7r6_RCQhuI0\" alt=\"2 12.51.35.jpeg\"></p>\n<p>*说明：</p>\n<ol>\n<li>兑换之后积分将被扣除；</li>\n<li>所有积分可折现为兑换物官方售价的 70% ，折现之后积分同上会扣除；</li>\n<li>由于本次捉虫积分有限，全部 1,000 个积分兑换之后，未兑换的积分将被冻结，下期「捉虫计划」积分上新时自动解冻。</li>\n</ol>\n<h4>兑换奖品</h4>\n<p>官方会统计每个在交流群或 GitHub 提交 issue &amp; pr 作者的 ID，兑奖需联系官方小助手：nbot 微信号：NebulaGraphbot 进行兑奖并扣除对应积分。</p>\n<h4>积分查看 &amp; 兑换记录</h4>\n<p>本次活动「积分表」和「兑换记录」可通过 NebulaGraph 小助手朋友圈或 NebulaGraph 知乎专栏 《众测 Nebula Graph | 捉虫计划已开启，这项有礼》查看，官方将在每日 12:00 更新「积分表」和「兑换记录」。</p>\n<h4>第一个积分获得者</h4>\n<p><img src=\"//static.cnodejs.org/Fs3UowpJwzGd590cC0_pA8Few7Rx\" alt=\"1.jpeg\"></p>\n<p><img src=\"//static.cnodejs.org/FjaQDX9I4Y0EegfEmcAwfCpX64pX\" alt=\"2.jpeg\"></p>\n<h3>⏰ 活动时间</h3>\n<p>即日 至 1,000 个积分兑换完毕</p>\n<h3>📚 合作社区</h3>\n<p>感谢以下技术社区对 Nebula Graph 捉虫计划的支持，再次鸣谢 😁</p>\n<p><img src=\"//static.cnodejs.org/FvGyA4hOHj0xO2gph0KFuyWH8Li_\" alt=\"掘金.png\"></p>\n<p><img src=\"//static.cnodejs.org/FsqInNkS9UxIsm60lw0JN_WZSK40\" alt=\"sf.png\"></p>\n<p><img src=\"//static.cnodejs.org/Fi5P_ZNuYJf5FDPMOK2xbXR37uSs\" alt=\"spring4all.png\"></p>\n<p><img src=\"//static.cnodejs.org/Fvx1xkWfZKEJI6k9cwjntZW0Wowf\" alt=\"CNode.png\"></p>\n<p><img src=\"//static.cnodejs.org/FkrdQEKRzHXi8Hkf6YSdOQaJUllM\" alt=\"TesterHome.png\"></p>\n<h3>📖 合作博客 &amp; 公众号</h3>\n<p>感谢以下个人博客&amp;公众号对 Nebula Graph 捉虫计划的支持 😁\n<img src=\"//static.cnodejs.org/FoeYVv0eRw9Mxe8p1RxmwLB42zan\" alt=\"公众号.png\"></p>\n<h3>🎊 官方助手</h3>\n<p>对「捉虫计划」有任何疑问，欢迎微信 Nebula Graph 小助手：NebulaGraphbot</p>\n<h3>🚪 活动传送门</h3>\n<p>点击<a href=\"https://strace.co/r/cnode\">👉这里</a>前往 GitHub 提 issue 🎉</p>\n</div>",
	"title": "众测图数据库 Nebula Graph | 捉虫计划已开启，这项有礼",
	"last_reply_at": "2019-08-23T14:56:12.364Z",
	"good": false,
	"top": true,
	"reply_count": 3,
	"visit_count": 1531,
	"create_at": "2019-08-21T03:31:49.789Z",
	"author": {
		"loginname": "QingZ11",
		"avatar_url": "https://avatars0.githubusercontent.com/u/38887077?v=4&s=120"
	}
}, {
	"id": "5d5bed6ed53e9171e98a975b",
	"author_id": "516f989a6d38277306ae8c1b",
	"tab": "share",
	"content": "<div class=\"markdown-text\"><p>这是一次硬核的地下铁沙龙，\n我们深入 Node.js 运行时底层，\n来讨论如何进行运行时的优化和诊断，\n让它可以在 Serverless，IoT 等等场景释放更大的价值。</p>\n<p>五位重量级的嘉宾，\n有 Node.js 基金会技术委员会（TSC）唯一中国成员，\n有来自浏览器厂商的骨灰级技术专家，\n还有阿里、Rokid 的大牛。</p>\n<p>欢迎你和我们一起，进入深海。</p>\n<p><strong>Agenda</strong>\n<img src=\"https://img.alicdn.com/tfs/TB10BqFdLb2gK0jSZK9XXaEgFXa-1408-2040.png\" alt=\"Agenda\"></p>\n<p>时 间：2019.09.08 下午 2 点\n地 点：杭州浙江大学玉泉校区（具体地址详见邀约）</p>\n<p>报 名 链 接: <a href=\"https://survey.alibaba.com/apps/zhiliao/QlwUc77lF\">https://survey.alibaba.com/apps/zhiliao/QlwUc77lF</a>\n活 动 主 页: <a href=\"https://fed.taobao.org/subway/\">https://fed.taobao.org/subway/</a></p>\n</div>",
	"title": "Node 地下铁第九期「杭州站」线下沙龙邀约 - Let's Go Deep",
	"last_reply_at": "2019-08-23T07:51:41.949Z",
	"good": false,
	"top": true,
	"reply_count": 7,
	"visit_count": 1797,
	"create_at": "2019-08-20T12:54:06.836Z",
	"author": {
		"loginname": "mariodu",
		"avatar_url": "//gravatar.com/avatar/1cb272a2b4347c9a15b502ce7e4802ba?size=48"
	}
}, {
	"id": "5cbfd9aca86ae80ce64b3175",
	"author_id": "4f447c2f0a8abae26e01b27d",
	"tab": "share",
	"content": "<div class=\"markdown-text\"><h2>前言</h2>\n<p>时隔一年，Node.js 12 如约而至，正式发布第一个 <a href=\"https://github.com/nodejs/Release\">Current</a> 版本。</p>\n<p>该版本带来了诸如：</p>\n<ul>\n<li>V8 更新带来好多不错的特性。</li>\n<li>HTTP 解析速度提升。</li>\n<li>启动速度大幅提升。</li>\n<li>更好的诊断报告和堆分析工具。</li>\n<li>ESM 模块更新。</li>\n</ul>\n<p>原文地址：<a href=\"https://medium.com/@nodejs/introducing-node-js-12-76c41a1b3f3f\">https://medium.com/@nodejs/introducing-node-js-12-76c41a1b3f3f</a>\n语雀地址：<a href=\"https://www.yuque.com/egg/nodejs/nodejs-12\">https://www.yuque.com/egg/nodejs/nodejs-12</a></p>\n<h2>LTS vs Current</h2>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2019/png/84182/1556074709431-35af45b8-ec7a-4a81-83d8-155eb519f04a.png#align=left&amp;display=inline&amp;height=389&amp;name=image.png&amp;originHeight=500&amp;originWidth=960&amp;size=58313&amp;status=done&amp;width=746\" alt=\"image.png\"></p>\n<p>如果你不了解 Node.js 的  Long Term Support 发布策略的话，一定要看看 <a href=\"https://github.com/nodejs/Release\">https://github.com/nodejs/Release</a> 。</p>\n<p>就目前而言，Node.js 6.x 和 8.x 将在 2019 年末结束 LTS 的支持，大家尽快升级到 10.x 吧。</p>\n<h2>快速体验</h2>\n<pre class=\"prettyprint language-bash\"><code>$ nvs add node&#x2F;12\n$ nvs use 12\n$ node -v\nv12.0.0\n</code></pre><p>具体参考这篇文章：<a href=\"https://zhuanlan.zhihu.com/p/63403762\">科普文：使用 nvs 管理本地 Node.js 版本</a></p>\n<h2>V8 更新到 7.4</h2>\n<blockquote>\n<p>大部分情况下，我们不用去考虑性能问题，坐等 V8 版本更新就好了。（大雾）</p>\n</blockquote>\n<p>本次版本更新，也带来了好几个不错的特性：</p>\n<ul>\n<li><a href=\"https://v8.dev/blog/v8-release-72#async-stack-traces\">异步堆栈跟踪</a></li>\n<li><a href=\"https://v8.dev/blog/v8-release-74#faster-calls-with-arguments-mismatch\">参数调用不匹配时的调用速度优化</a></li>\n<li><a href=\"https://v8.dev/blog/v8-release-73#faster-await\">更快的 await</a></li>\n<li><a href=\"https://v8.dev/blog/v8-release-72#javascript-parsing\">更快的 JavaScript 解析速度</a></li>\n</ul>\n<p><strong>同时，跑了下我们 Egg 的一些内部测试，发现序列化有 10~20% 的性能提升，恐怖如斯！</strong></p>\n<p>另，奇丑无比的 <a href=\"https://github.com/tc39/proposal-class-fields\">Private Class Fields</a> 也能用了：</p>\n<pre class=\"prettyprint language-javascript\"><code>class IncreasingCounter {\n  #count = 0;\n  \n  get value() {\n    console.log(&#x27;Getting the current value!&#x27;);\n    return this.#count;\n  }\n  increment() {\n    this.#count++;\n  }\n}\n</code></pre><h2>HTTP 解析速度提升</h2>\n<p>默认的 HTTP 解析器切换为 <a href=\"https://github.com/nodejs/llhttp\">llhttp</a> ，性能提升恐怖如斯：</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2019/png/84182/1556072499637-686bb0e3-c75c-424c-851f-ad88aff183a2.png#align=left&amp;display=inline&amp;height=231&amp;name=image.png&amp;originHeight=404&amp;originWidth=1302&amp;size=88775&amp;status=done&amp;width=746\" alt=\"image.png\"></p>\n<blockquote>\n<p>点评：恐怖如斯。</p>\n</blockquote>\n<h2>启动速度提升</h2>\n<p>通过 <a href=\"https://v8.dev/blog/code-caching\">v8 code cache</a> 的支持，<a href=\"https://github.com/nodejs/node/pull/27161\">在构建时提前为内置库生成代码缓存</a>，从而提升 30% 的启动耗时。\n同时，通过<a href=\"https://github.com/nodejs/node/pull/24950\">重用主进程缓存</a>，Workers Threads 的启动速度提升了 60% 。</p>\n<blockquote>\n<p>点评：恐怖如斯。</p>\n</blockquote>\n<h2>Workers Threads</h2>\n<p>在 10.x 已经引入的 <a href=\"https://nodejs.org/api/worker_threads.html\">Workers Threads</a> 特性，在 12.x 里面默认启用，无需使用 <code>--experimental-worker</code> 开启。同时基于上一条的介绍，启动的速度也得到大幅提升。</p>\n<p>相关介绍：<a href=\"https://medium.com/@Trott/using-worker-threads-in-node-js-80494136dbb6\">https://medium.com/@Trott/using-worker-threads-in-node-js-80494136dbb6</a></p>\n<h2>诊断报告</h2>\n<p>提供了新的实验性功能『诊断报告』，一个非常有用的特性。\n可用于帮助分析诸如：崩溃，性能问题，内存泄漏，高 CPU 占用等等问题。详见 <a href=\"https://medium.com/the-node-js-collection/easily-identify-problems-in-node-js-applications-with-diagnostic-report-dc82370d8029\">这篇文章</a>。</p>\n<blockquote>\n<p>点评：这也是 <a href=\"https://www.aliyun.com/product/nodejs\">AliNode</a> 之前的一个卖点之一。</p>\n</blockquote>\n<h2>Heap Dump</h2>\n<p>以前我们分析问题的时候，需要手动安装对应的类库或者使用 AliNode。</p>\n<p>在 12.x 里面内置了该功能，详见：</p>\n<ul>\n<li><a href=\"https://github.com/nodejs/node/pull/27133\">https://github.com/nodejs/node/pull/27133</a></li>\n<li><a href=\"https://github.com/nodejs/node/pull/26501\">https://github.com/nodejs/node/pull/26501</a></li>\n</ul>\n<blockquote>\n<p>点评：又一个 <a href=\"https://www.aliyun.com/product/nodejs\">AliNode</a> 的功能被内置了。但其实影响不大，AliNode 的核心在于分析平台，这块的采集能力，本来他们就打算开源回馈出去的。</p>\n</blockquote>\n<p>同时，由于上述提到的 V8 升级，现在可以按照可用内存动态调整堆大小了。</p>\n<h2>ESM 模块方案更新</h2>\n<p>ES6 模块仍然还在实验阶段，不过有了新的方式，具体参见<a href=\"https://medium.com/@nodejs/announcing-a-new-experimental-modules-1be8d2d6c2ff\">这篇文章</a>。</p>\n<blockquote>\n<p>点评：让子弹再飞一会，该特性真的不是痛点，不急。</p>\n</blockquote>\n<h2>其他更新</h2>\n<ul>\n<li>更好的原生模块支持，<a href=\"https://nodejs.org/api/n-api.html#n_api_n_api\">N-API</a> 升级为版本 4，并 backport 到 Node.js 8.x 和 10.x。详细参见<a href=\"https://medium.com/the-node-js-collection/new-features-bring-native-add-ons-close-to-being-on-par-with-js-modules-cd4f9b8e4b4\">这篇文章</a>。</li>\n<li>TLS 升级为 1.3， <a href=\"https://developer.ibm.com/blogs/openssl-111-has-landed-in-nodejs-master-and-why-its-important-for-nodejs-lts-releases/\">增强安全功能</a>。</li>\n<li>随着 C++ 编译器的更新，现在要求 <code>GCC 6</code> 和 <code>glibc 2.17</code> ，对应的操作系统 Win7 和 macOS 10，详细参见<a href=\"https://github.com/nodejs/node/blob/v12.x/BUILDING.md#platform-list\">这篇文章</a>。</li>\n</ul>\n<p>不过目前 node-gyp 的一些原生模块会编译失败：</p>\n<pre class=\"prettyprint language-bash\"><code>nunjucks@3.2.0 › chokidar@2.1.5 › fsevents@^1.2.7 optional error: Error: Run &quot;sh -c node install&quot; error, exit code 1\n    at ChildProcess.&lt;anonymous&gt; (&#x2F;Users&#x2F;tz&#x2F;.npm-global&#x2F;lib&#x2F;node_modules&#x2F;tnpm&#x2F;node_modules&#x2F;_runscript@1.3.0@runscript&#x2F;index.js:74:21)\n    at ChildProcess.emit (events.js:196:13)\n    at maybeClose (internal&#x2F;child_process.js:1000:16)\n    at Process.ChildProcess._handle.onexit (internal&#x2F;child_process.js:267:5)\n</code></pre></div>",
	"title": "Node 12 值得关注的新特性",
	"last_reply_at": "2019-08-19T09:55:20.970Z",
	"good": false,
	"top": true,
	"reply_count": 57,
	"visit_count": 116372,
	"create_at": "2019-04-24T03:36:12.582Z",
	"author": {
		"loginname": "atian25",
		"avatar_url": "https://avatars2.githubusercontent.com/u/227713?v=4&s=120"
	}
}, {
	"id": "5bd4772a14e994202cd5bdb7",
	"author_id": "504c28a2e2b845157708cb61",
	"tab": "share",
	"content": "<div class=\"markdown-text\"><p>2018年10月27日晚上，突然收到服务器不能访问的告警通知，拜托了狼叔 <a href=\"/user/i5ting\">@i5ting</a> 帮忙看看，结果登不上也ping不通。\n后来收到短信，发现是被ucloud封了，短信内容如下：</p>\n<blockquote>\n<p>【UCloud】尊敬的UCloud用户，您的IP：123.59.77.142  存在URL ：<a href=\"https://cnodejs.org/topic/57239bce5a26c4a841ecbf01\">https://cnodejs.org/topic/57239bce5a26c4a841ecbf01</a> （详细信息请查看邮箱）包含违禁内容（包括但不限于翻墙等），违反了国家有关法律法规。目前依主管单位要求，对您的IP予以封停，请您尽快处理违规内容。待处理完成后请联系技术支持重新开启业务。[4000188113]</p>\n</blockquote>\n<p>然后联系了ucloud的客服，一下就打通了，对方态度挺好处理问题也快。ucloud说是运营商那边封的，不是他们的检测机制。所以需要联系运营商解决。\n考虑到各位亲爱的网友们的行为我无法控制，那么一直跟越来越严格的审查系统对抗只会让自己疲惫，所以我就站点迁到国外。来到了aws jp。</p>\n<p>我大致测了测，电信和移动的访问速度非常快，100ms以内，联通会慢一点，400ms以内吧。</p>\n<p>建议翻墙访问。</p>\n</div>",
	"title": "服务器迁移至 aws 日本机房",
	"last_reply_at": "2019-08-18T03:16:56.213Z",
	"good": false,
	"top": true,
	"reply_count": 202,
	"visit_count": 94196,
	"create_at": "2018-10-27T14:33:14.694Z",
	"author": {
		"loginname": "alsotang",
		"avatar_url": "https://avatars1.githubusercontent.com/u/1147375?v=4&s=120"
	}
}, {
	"id": "5d36c34effed731686461c92",
	"author_id": "5ccfb46f5a5bae6e078134e7",
	"tab": "share",
	"content": "<div class=\"markdown-text\"><h5>接入前准备</h5>\n<ul>\n<li>通过 <a href=\"https://payjq.cn\">Payjq</a> 注册个人收款接口，原理是帮助你签约微信和支付宝（不需要营业执照），大概几分钟可以开通，开通后即可永久使用。</li>\n</ul>\n<h6><a href=\"https://help.payjq.cn/api-lie-biao/sao-ma-zhi-fu-ff08-zhu-sao-ff09.html\">NATIVE 扫码支付</a></h6>\n<ul>\n<li>\n<p>效果：用户点击支付后，前端网络请求你的后台，你后台再请求 Payjq支付接口返回支付二维码到前台，页面展示微信或者支付宝二维码，用户用手机微信或支付宝扫码支付</p>\n</li>\n<li>\n<p>扫码请求步骤：</p>\n<ul>\n<li>构建请求参数</li>\n<li>POST 参数到请求地址</li>\n<li>根据返回内容展示二维码</li>\n<li>用户支付成功后接收异步通知</li>\n</ul>\n</li>\n<li>\n<p>适用场景：PC网站、PC软件、APP</p>\n</li>\n</ul>\n<h6><a href=\"https://help.payjq.cn/api-lie-biao/jsapizhi-fu.html\">JSAPI 支付</a></h6>\n<ul>\n<li>\n<p>效果：用户在微信浏览器内点击支付后，跳出支付页面，输入指纹/支付密码完成支付</p>\n</li>\n<li>\n<p>JSAPI接口请求步骤：</p>\n<ul>\n<li>获得 OPENID</li>\n<li>通过该 api 构造订单参数获取 jsapi 支付参数</li>\n<li>通过 jssdk 或 WeixinJsBridge 方式自行发起支付</li>\n<li>服务端接收异步通知</li>\n</ul>\n</li>\n<li>\n<p>适用场景：用户在微信内进行的H5页面，页面内调用JSSDK完成支付。例如：微信公众号</p>\n</li>\n</ul>\n<h6><a href=\"https://help.payjq.cn/api-lie-biao/shou-yin-tai-zhi-fu.html\">收银台支付</a></h6>\n<ul>\n<li>\n<p>效果：收银台方式同样是通过JSAPI方式发起的支付，只是简化了步骤和流程。适用于微信webview环境</p>\n</li>\n<li>\n<p>收银台请求步骤：</p>\n<ul>\n<li>构建请求参数</li>\n<li>使用浏览器携带参数跳转至收银台地址</li>\n<li>用户在收银台界面点击按钮发起支付</li>\n<li>服务端接收异步通知</li>\n</ul>\n</li>\n</ul>\n<h4>PayJQ支付平台介绍</h4>\n<blockquote>\n<p>PayJQ 定位为个人 / 独立开发者 / 个体户 / 小微企业提供安全、简单、稳定、正规的收款服务。支持微信 NATIVE / JSAPI / 收银台 等支付方式，资金由微信官方T+1结算自动下发个人银行卡。支付宝支付渠道也在内测。</p>\n</blockquote>\n<h4>为什么开发 PayJQ 支付平台</h4>\n<blockquote>\n<p>我们知道作为个人或者初创团队产品需要收款是多么麻烦，注册公司维护成本太高。市面上各种收款工具要么是监听，稳定性差，体验不好；要么是二清，资金随时都有风险。于是我们开发了「PayJQ 支付平台」用来解决这个问题，提交资料，极速开通使用。</p>\n</blockquote>\n<h4>支持接口</h4>\n<ul>\n<li><a href=\"https://help.payjq.cn/api-lie-biao/sao-ma-zhi-fu-ff08-zhu-sao-ff09.html\">NATIVE 扫码支付</a></li>\n<li><a href=\"https://help.payjq.cn/api-lie-biao/fu-kuan-ma-zhi-fu-ff08-bei-sao-ff09.html\">付款码支付</a></li>\n<li><a href=\"https://help.payjq.cn/api-lie-biao/shou-yin-tai-zhi-fu.html\">收银台支付</a></li>\n<li><a href=\"https://help.payjq.cn/api-lie-biao/jsapizhi-fu.html\">JSAPI 网页支付</a></li>\n<li><a href=\"https://help.payjq.cn/api-lie-biao/ding-dan-cha-xun.html\">订单查询</a></li>\n<li><a href=\"https://help.payjq.cn/api-lie-biao/tui-kuan.html\">退款</a></li>\n<li><a href=\"https://help.payjq.cn/api-lie-biao/yi-bu-tong-zhi.html\">异步通知</a></li>\n<li><a href=\"https://help.payjq.cn/api-lie-biao/huo-qu-openid.html\">获取 OPENID</a></li>\n<li><a href=\"https://help.payjq.cn/api-lie-biao/qian-ming-suan-fa.html\">签名算法</a></li>\n</ul>\n<h4>链接</h4>\n<ul>\n<li><a href=\"https://payjq.cn\">PayJQ官网</a></li>\n<li><a href=\"https://help.payjq.cn\">API文档</a></li>\n</ul>\n<h4>客服</h4>\n<ul>\n<li>客服微信：payjq_cn</li>\n<li>客服QQ：51653872</li>\n</ul>\n</div>",
	"title": "个人网站实现收款的几种方式",
	"last_reply_at": "2019-08-24T05:53:58.272Z",
	"good": false,
	"top": false,
	"reply_count": 19,
	"visit_count": 2719,
	"create_at": "2019-07-23T08:20:30.845Z",
	"author": {
		"loginname": "zilin9980",
		"avatar_url": "https://avatars3.githubusercontent.com/u/50311116?v=4&s=120"
	}
}, {
	"id": "5d5e9c9c421846662d98428e",
	"author_id": "5ce742f34036f24194cf5fa1",
	"tab": "ask",
	"content": "<div class=\"markdown-text\"><p>多列举几个 各有什么优势</p>\n</div>",
	"title": "node.js 有什么做优秀GUI界面的库？",
	"last_reply_at": "2019-08-24T05:44:25.117Z",
	"good": false,
	"top": false,
	"reply_count": 5,
	"visit_count": 602,
	"create_at": "2019-08-22T13:46:04.017Z",
	"author": {
		"loginname": "XiaoShouMr",
		"avatar_url": "https://avatars3.githubusercontent.com/u/50972319?v=4&s=120"
	}
}, {
	"id": "5d60b187421846662d9846a7",
	"author_id": "5d5218a412a01945444162a9",
	"tab": "ask",
	"content": "<div class=\"markdown-text\"><p>惭愧，不会用Git。\n现在问题是这样的，我在用flutter开发APP，现在有个bug，有人提交了pull request，貌似解决了，那么我怎么把他的pull request的代码下载到我本地，我自己又能用呢？\n就是这个pull request：<a href=\"https://github.com/flutter/flutter/pull/36616\">https://github.com/flutter/flutter/pull/36616</a></p>\n</div>",
	"title": "各位大佬，我问个Git的问题",
	"last_reply_at": "2019-08-24T03:39:51.971Z",
	"good": false,
	"top": false,
	"reply_count": 0,
	"visit_count": 55,
	"create_at": "2019-08-24T03:39:51.971Z",
	"author": {
		"loginname": "wuyugege",
		"avatar_url": "https://avatars0.githubusercontent.com/u/11754341?v=4&s=120"
	}
}, {
	"id": "5b8de66137b3005a0b0e6b3f",
	"author_id": "5b8de41bbf116a8c0e42579f",
	"tab": "share",
	"content": "<div class=\"markdown-text\"><p>Egg.js入门视频教程主要讲了Egg的环境搭建   egg的控制器      egg服务  egg中间件   egg路由 egg扩展   egg模板引擎  egg cookie   egg session</p>\n<p><strong>Eggjs 视频教程百度网盘分享接</strong>： <a href=\"https://pan.baidu.com/s/1t6XHpny8-H8mApLkzcsS8w\">https://pan.baidu.com/s/1t6XHpny8-H8mApLkzcsS8w</a></p>\n<p><strong>或者此连接Egg.js视频教程10讲入门链接</strong>： <a href=\"https://pan.baidu.com/s/1-jdCXKGgfk9yI8xJOOhPhg\">https://pan.baidu.com/s/1-jdCXKGgfk9yI8xJOOhPhg</a>  <strong>密码</strong>：4b6i</p>\n<p><strong>来源</strong>  <a href=\"https://cnodejs.org/topic/5b7ac9c7c52ad1482eb940bf\">https://cnodejs.org/topic/5b7ac9c7c52ad1482eb940bf</a></p>\n<p>希望老铁门能喜欢\n<img src=\"//static.cnodejs.org/FoPZNWCMpHqWFAb2QDns-UhIMX-3\" alt=\"egg01.png\"></p>\n<p><img src=\"//static.cnodejs.org/Fu4_-OevpWiKHFqeEGBOW53MCdnE\" alt=\"egg02.png\"></p>\n<p><img src=\"//static.cnodejs.org/FtOEkaeRTUNyuWE2mhvazrxPc6cd\" alt=\"egg03.png\"></p>\n<p><img src=\"//static.cnodejs.org/FtJsuDe3kbcNYWWcJyfxuE08wVs5\" alt=\"egg05.png\"></p>\n<p><img src=\"//static.cnodejs.org/Fp8erhbPkGZrsYFsd-gxn2z4Gssb\" alt=\"222.png\"></p>\n<p><img src=\"//static.cnodejs.org/FhCAuCKVwbQnTCJWtkGKv6ZR8toN\" alt=\"06.png\"></p>\n</div>",
	"title": "Egg.js视频教程-Eggjs入门视频教程网盘免费分享-10讲入门基础希望老铁门能喜欢",
	"last_reply_at": "2019-08-24T02:01:40.771Z",
	"good": false,
	"top": false,
	"reply_count": 97,
	"visit_count": 18001,
	"create_at": "2018-09-04T01:56:49.179Z",
	"author": {
		"loginname": "zlyuanteng",
		"avatar_url": "https://avatars0.githubusercontent.com/u/42952042?v=4&s=120"
	}
}, {
	"id": "5d5e27eae79eaa6628beb7b9",
	"author_id": "555f40ac4eb040084cfe5ceb",
	"tab": "share",
	"content": "<div class=\"markdown-text\"><h2>0. 写在前面</h2>\n<p>可以在 <a href=\"https://github.com/nodemcujs/nodemcujs-firmware\">nodemcujs</a> 直接下载编译好的固件。可以在 <a href=\"http://timor.tech/shop/\">提莫的神秘商店</a> 获取 ESP32 开发板。更多好玩的东西在 <a href=\"http://timor.tech\">http://timor.tech</a>。</p>\n<p>本文的主要目的是描述如何让 ESP32 芯片运行 JavaScript，并且让 web 前端开发人员也能玩转硬件。\n作者之前是 web 前端开发工程师，所以文章会尽量站在 web 前端开发工程师的角度，抛开底层的硬件知识，去掉一些目前不需要关心的，将重点放在软件上。\n尽管这样，我们接下来所要做的是 硬件+软件 的一个整体，所以一些基础的 C 语言和硬件知识会让你更好的阅读此文章。没有也不要紧，因为高深的我也不会阿！</p>\n<p>文章会分为 2 个篇幅进行讲解。其中基础篇会先介绍基础知识，有以下几个部分：</p>\n<ol>\n<li>ESP32 硬件介绍</li>\n<li>JerryScript 简单介绍</li>\n<li>FreeRTOS 简单介绍</li>\n</ol>\n<p>实战篇将会介绍如何在 ESP32 芯片上面运行 JerryScript，有以下几个部分：</p>\n<ol>\n<li>让 JerryScript 运行并接受串口输入</li>\n<li>使用片上存储芯片：flash</li>\n<li>实现 JS 文件模块</li>\n</ol>\n<h2>1. ESP32 硬件介绍</h2>\n<p>首先先介绍一下 ESP32 是个什么东西，简单来说，它就是一块集成了 WiFi、蓝牙、天线、功率放大器、电源管理模块、CPU、存储器、传感器的单片机微控制器，说人话就是：它能存储并运行我们的代码，还具有 WiFi 和蓝牙功能。先来看一张图吧:</p>\n<p><img src=\"//static.cnodejs.org/FkCXU3zTwFhR2pby58rqKkCKipah\" alt=\"esp32.png\"></p>\n<p>左边一块比较大的就是 ESP32 模组，上面提到的所有硬件配置都集成在这片模组上。下面的板子和其它元件是为了方便开发以及芯片启动必要的电路连接，而做成的一个开发板。这个开发板加了电源转换芯片，使得支持 3.3 - 5V 电压，右边小的方块型的是 cp2102 USB转串口芯片，使得我们可以使用 USB 线连接电脑。这个板子把引脚都引出来了，方便使用杜邦线连接各种外围器件。下面我们说的 ESP32 都表示这整块开发板，而不是 ESP32 模组本身。</p>\n<p>ESP32 采用两个哈佛结构 Xtensa LX6 CPU 构成双核系统，时钟频率在 80MHz - 240MHz 范围内可调。片上集成了 520KB SRAM， 448KB ROM。拥有 41 个外设模块，包含常见的 IIC, SPI, UART, PWM, IR, I2S, SDIO 等。常见的协议基本都有了，这使得我们可以更方便的和大部分电子模块或外设进行通信，而不需要像 51 单片机一样，使用软件模拟实现。比如常见的 SSD12864 oled 屏幕，同时具有 IIC 和 SPI 的接口。BLOX-NEO-6M GPS 模块是使用的 UART 接口。直流电机和伺服机可以使用 PWM 驱动。电风扇、空调等用的是 IR 红外线传输信号。</p>\n<p>除此之外，ESP32 还集成了片上传感器和模拟信号处理器。比如电容式触摸传感器，霍尔传感器，ADC，DAC 等。如果我们设计了有电池的产品，有了 ADC，我们就可以方便的测量电池的电量，虽然这样测量的值不一定准。</p>\n<p>以上是单片机系统中很常见的外设，ESP32 将它们都集成在一个片上系统中了。但 ESP32 最让人激动的是，它集成了 WIFI 和 蓝牙。有了 WIFI 和 蓝牙，再配合各种外设，GPIO，我们就能拿它做很多事情，比如温度湿度传感器的值直接上传到服务器。远程下发执行指令开关灯等，尽可以发挥你的想象。</p>\n<p>但硬件编程对于软件工程师来说却实门槛有点高，尤其像我们 web前端开发工程师，C 语言就是第一道门槛。我一直想将 JavaScript 带到硬件编程中去，这样我们就可以使用熟悉的 JavaScript 发挥我们的创意。所以才有了本篇文章。</p>\n<h2>2. JerryScript 简单介绍</h2>\n<p>Node.js 很强大，但它是建立在 V8 和 libuv 之上的， ESP32 片上 SRAM 只有 520KB，别说 v8 了，libuv 都跑不起来。所以我们需要一个轻量的，为嵌入式设计的 JavaScript 引擎，幸运的是，我们有 <a href=\"https://jerryscript.net/\">JerryScript</a>。</p>\n<p>JerryScript 是一个轻量级的 JavaScript 引擎，它可以运行在受限制的设备上，例如微控制器，它能在 RAM &lt; 64 KB， ROM &lt; 200 KB 的设备上运行。而且它还提供了完整的 ES5.1 语法支持，以及部分 ES6 语法支持，比如 箭头函数，Symbol， Promise 等。在编程体验上虽然没有 v8 这么爽，但有这些就已经很好了啊（相对于其它的嵌入式 JavaScript 引擎来说）！</p>\n<p>还有一个重要的点是 JerryScript 的 api 更符合我们的编程习惯，对于已经习惯编写 Node.js addon 的人来说会更容易接受。所以以上2点，是我们选择 JerryScript 的理由。为了让大家更直观的理解，下面我们对比2个目前在嵌入式比较流行的 JavaScript 引擎。</p>\n<h4>duktape</h4>\n<p><a href=\"https://duktape.org/\">duktape</a> 目前在 github 上面是 3.7K 个 Star，下面是官网的 hello world!</p>\n<pre class=\"prettyprint language-c\"><code>#include &lt;stdio.h&gt;\n#include &quot;duktape.h&quot;\n\n&#x2F;* Adder: add argument values. *&#x2F;\nstatic duk_ret_t native_adder(duk_context *ctx) {\n  int i;\n  int n = duk_get_top(ctx);  &#x2F;* #args *&#x2F;\n  double res = 0.0;\n\n  for (i = 0; i &lt; n; i++) {\n    res += duk_to_number(ctx, i);\n  }\n\n  duk_push_number(ctx, res);\n  return 1;  &#x2F;* one return value *&#x2F;\n}\n\nint main(int argc, char *argv[]) {\n  duk_context *ctx = duk_create_heap_default();\n\n  duk_push_c_function(ctx, native_adder, DUK_VARARGS);\n  duk_put_global_string(ctx, &quot;adder&quot;);\n\n  duk_eval_string(ctx, &quot;adder(1+2);&quot;);\n  printf(&quot;1+2=%d\\n&quot;, (int) duk_get_int(ctx, -1));\n\n  duk_destroy_heap(ctx);\n  return 0;\n}\n</code></pre><h4>JerryScript</h4>\n<pre class=\"prettyprint language-c\"><code>#include &quot;jerryscript.h&quot;\n#include &quot;jerryscript-ext&#x2F;handler.h&quot;\n\nstatic jerry_value_t adder_handler(const jerry_value_t func_value, &#x2F;**&lt; function object *&#x2F;\n                                   const jerry_value_t this_value, &#x2F;**&lt; this arg *&#x2F;\n                                   const jerry_value_t args[],    &#x2F;**&lt; function arguments *&#x2F;\n                                   const jerry_length_t args_cnt)  &#x2F;**&lt; number of function arguments *&#x2F;\n{\n  double total = 0;\n  uint32_t argIndex = 0;\n\n  while (argIndex &lt; args_cnt)\n  {\n    double = double + jerry_get_number_value(args[argIndex]);\n    argIndex++;\n  }\n  return jerry_create_number(total);\n}\n\nint main (void)\n{\n  const jerry_char_t script[] = &quot;print(adder(1, 2));&quot;;\n\n  &#x2F;* Initialize engine *&#x2F;\n  jerry_init (JERRY_INIT_EMPTY);\n\n  &#x2F;* Register &#x27;print&#x27; function from the extensions *&#x2F;\n  jerryx_handler_register_global ((const jerry_char_t *) &quot;print&quot;, jerryx_handler_print);\n\n  &#x2F;* Register &#x27;adder&#x27; function from the extensions *&#x2F;\n  jerryx_handler_register_global ((const jerry_char_t *) &quot;adder&quot;, adder_handler);\n\n  &#x2F;* Setup Global scope code *&#x2F;\n  jerry_value_t parsed_code = jerry_parse (NULL, 0, script, sizeof (script) - 1, JERRY_PARSE_NO_OPTS);\n\n  if (!jerry_value_is_error (parsed_code))\n  {\n    &#x2F;* Execute the parsed source code in the Global scope *&#x2F;\n    jerry_value_t ret_value = jerry_run (parsed_code);\n\n    &#x2F;* Returned value must be freed *&#x2F;\n    jerry_release_value (ret_value);\n  }\n\n  &#x2F;* Parsed source code must be freed *&#x2F;\n  jerry_release_value (parsed_code);\n\n  &#x2F;* Cleanup engine *&#x2F;\n  jerry_cleanup ();\n\n  return 0;\n}\n\n</code></pre><h2>3. FreeRTOS 简单介绍</h2>\n<p><a href=\"https://www.freertos.org\">FreeRTOS</a> 是一个热门的嵌入式设备用即时操作系统核心，它设计小巧且简易，大部分的代码由 C 语言编写。它提供多任务，互斥锁，信号量，和软件定时器等功能，让用户可以快速的进行应用程序设计。</p>\n<p>以上是维基百科的介绍，简单来说主要就是为设计多任务的应用程序提供基本的工具库，让应用开发者可以专注于逻辑的实现，而没必要自己实现任务管理和调度。因为在单片机上编程是没有像 Linux 一样的多进程，多线程的概念的，单片机上电启动后就从指定地址加载指令，按照顺序执行完。</p>\n<p>单片机一般来说只有一个处理器，同一时间只能处理一个任务，假如你想让 2 个 LED 交替闪烁，那么你必须在 <code>while(true){...}</code> 循环内手动控制 2 个 LED 逻辑代码的执行时间，假如后续有 3 个，4 个，N 个呢？那么所有的逻辑都得写在里面，会非常庞大。</p>\n<p>FreeRTOS 的任务能让各个逻辑跑在单独的 Task 中互不干扰，各 Task 以优先级抢占 CPU 时间。值得注意的是，即使使用了 FreeRTOS，整个应用仍然是单线程的，高优先级任务执行完后，必须要让出 CPU 时间才能让其它低优先级任务执行。记住，单片机只有一个处理器，同一时间只能处理一个任务。</p>\n<p>整个 FreeRTOS 的任务是一个链表，从任务列表中取出最高优先级的任务执行，执行完后再取出下一优先级任务，一直循环。不过有几点不同，FreeRTOS 永远保证高优先级任务先执行，所以低优先级任务有可能没有机会执行。每次执行完任务后，从列表中取出下一个任务时，都会重新计算优先级。执行中的任务只能由任务自身让出 CPU 时间，否则其它任务没有机会执行，当然除了中断。FreeRTOS 是实时操作系统，你可以精确控制各个任务的开始和结束时间。</p>\n<h1>实战篇</h1>\n<h2>1. 让 JerryScript 运行并接受串口输入</h2>\n<p>以上介绍完了基础知识，下面我们开始让 JerryScript 在 ESP32 上面跑起来，并让串口接收用户输入，将它输入 JerryScript 中执行。</p>\n<p>首先需要准备好 <a href=\"https://docs.espressif.com/projects/esp-idf/zh_CN/latest/index.html\">ESP-IDF</a> 开发环境，然后新建一个空的工程，我推荐从 <a href=\"https://github.com/espressif/esp-idf/tree/master/examples/get-started/hello_world\">idf-hello-world</a> 新建。JerryScript 将作为一个外部依赖放在 <code>deps/JerryScript</code> 目录。JerryScript 源码地址：<a href=\"https://jerryscript.net/\">JerryScript</a>。</p>\n<p>最终我们的工程目录是这样的：</p>\n<pre class=\"prettyprint language-txt\"><code>- build\n- deps\n  - jerryscript\n- components\n- main\n- spiffs\n- partitions.csv\n- CMakeLists.txt\n- sdkconfig\n</code></pre><ul>\n<li><code>build</code> 是我们的构建目录，构建过程中的所有临时文件都在这里，方便清理。</li>\n<li><code>deps</code> 是存放第三方依赖的目录，JerryScript 将作为一个依赖，这样方便管理，可以和官方保持同步。</li>\n<li><code>components</code> 是存放<a href=\"https://docs.espressif.com/projects/esp-idf/zh_CN/latest/api-guides/build-system.html#component-directories\">用户组件</a>的目录，我们自己编写的组件都放在这里。</li>\n<li><code>main</code> 是一个特殊的组件，作为应用的主程序。</li>\n<li><code>spiffs</code> 是存放内置文件系统的目录，里面的所有文件都会被打包成一个二进制文件，方便烧录到芯片上。</li>\n<li><code>partitions.csv</code> 是分区表配置文件，每一个应用都需要配置一个分区表，这里使用默认的就行了。</li>\n<li><code>CMakeLists.txt</code> 是工程的主构建文件，整个工程的构建将从这里开始。</li>\n<li><code>sdkconfig</code> 是工程的配置文件，可以配置系统参数和一些用户自定义的参数。</li>\n</ul>\n<p>以上所有都准备好后，可以开始写代码了。ESP32 的 CPU 型号是 Xtensa 32-bit LX6，所以我们需要编写 JerryScript 的交叉编译，然后将静态库链接到 main 组件中去，这样 JerryScript 才能运行起来。</p>\n<p>下面是主 CMakeLists.txt 文件内容，主要是指定 JerryScript 的源码目录，这样方便在其它组件内使用。然后设置 <code>JERRY_GLOBAL_HEAP_SIZE</code> 为 128KB。\n<code>JERRY_GLOBAL_HEAP_SIZE</code> 表示 JerryScript 虚拟机预先申请的内存大小，在虚拟机启动时就会向系统预先申请指定大小的内存。\n因为 ESP32 内存总共才 520KB，而 JerryScript 默认的 heap_size 也是 512KB，这样肯定是编译不过的，会报溢出错误。</p>\n<pre class=\"prettyprint language-cmake\"><code>cmake_minimum_required(VERSION 3.5)\n\nset(JERRYSCRIPT_SOURCE &quot;${CMAKE_SOURCE_DIR}&#x2F;deps&#x2F;jerryscript&quot;)\n\n# JerryScript setting here\nset(JERRY_GLOBAL_HEAP_SIZE &quot;(128)&quot;)\n\ninclude($ENV{IDF_PATH}&#x2F;tools&#x2F;cmake&#x2F;project.cmake)\nproject(nodemcujs)\n</code></pre><p>主 cmake 编写好后，接下来是编写 main 组件的 cmake 文件。要使用 JerryScript 非常简单，只需要链接 JerryScript 的静态库，然后配置正确的头文件路径。JerryScript 默认会编译为静态库，我们在 main 组件中将它们链接就行。</p>\n<p>下面是 main 组件的 CMakeLists.txt，内容有点多，这里只选择关键的讲解，详情请看 <a href=\"https://github.com/nodemcujs/nodemcujs-firmware\">nodemcujs</a> 项目:</p>\n<pre class=\"prettyprint language-cmake\"><code>set(COMPONENT_PRIV_INCLUDEDIRS\n    ${JerryScript_SOURCE}&#x2F;jerry-core&#x2F;include\n    ${JerryScript_SOURCE}&#x2F;jerry-ext&#x2F;include\n    ${JerryScript_SOURCE}&#x2F;jerry-port&#x2F;default&#x2F;include)\n</code></pre><p>上面是设置 JerryScript 的头文件查找路径。下面将进行 JerryScript 的交叉编译，并把编译后的静态库链接到 main 组件：</p>\n<pre class=\"prettyprint language-cmake\"><code># Xtensa processor architecture optimization\nset(EXTERNAL_COMPILE_FLAGS -ffunction-sections -fdata-sections -fstrict-volatile-bitfields -mlongcalls -nostdlib -w)\nstring(REPLACE &quot;;&quot; &quot;|&quot; EXTERNAL_COMPILE_FLAGS_ALT_SEP &quot;${EXTERNAL_COMPILE_FLAGS}&quot;)\n</code></pre><p>上面是设置交叉编译的参数，针对 xtensa 处理器，不加这个参数链接通不过。尤其注意 <code>-mlongcalls</code> 参数，此参数虽然被设置为编译参数，但它实际是作用在汇编的。如果你看到 <code>dangerous relocation: call0: call target out of range</code> 这个错误，多半是忘记加这个参数了。详情请看 <a href=\"https://embarc.org/man-pages/gcc/Xtensa-Options.html\">xtensa-gcc-longcalls</a> 编译器的文档。\n注意，这里的都需要写在 <code>register_component()</code> 后面，否则会报错。</p>\n<p>编译参数设置好后，下面是使用 <code>externalproject_add</code> 将 JerryScript 作为外部工程单独编译，不能使用 <code>add_subdirectory</code>，cmake 会报错。</p>\n<pre class=\"prettyprint language-cmake\"><code>externalproject_add(jerryscript_build\n  PREFIX ${COMPONENT_DIR}\n  SOURCE_DIR ${JERRYSCRIPT_SOURCE}\n  BUILD_IN_SOURCE 0\n  BINARY_DIR jerryscript\n  INSTALL_COMMAND &quot;&quot; # Do not install to host\n  LIST_SEPARATOR | # Use the alternate list separator\n  CMAKE_ARGS\n    -DJERRY_GLOBAL_HEAP_SIZE=${JERRY_GLOBAL_HEAP_SIZE}\n    -DJERRY_CMDLINE=OFF\n    -DENABLE_LTO=OFF # FIXME: This option must be turned off or the cross-compiler settings will be overwritten\n    -DCMAKE_C_COMPILER_WORKS=true # cross-compiler\n    -DCMAKE_SYSTEM_NAME=Generic\n    -DCMAKE_SYSTEM_PROCESSOR=xtensa\n    -DCMAKE_C_COMPILER=${CMAKE_C_COMPILER}\n    -DEXTERNAL_COMPILE_FLAGS=${EXTERNAL_COMPILE_FLAGS_ALT_SEP}\n    -DCMAKE_EXE_LINKER_FLAGS=${CMAKE_EXE_LINKER_FLAGS}\n    -DCMAKE_LINKER=${CMAKE_LINKER}\n    -DCMAKE_AR=${CMAKE_AR}\n    -DCMAKE_NM=${CMAKE_NM}\n    -DCMAKE_RANLIB=${CMAKE_RANLIB}\n    -DCMAKE_FIND_ROOT_PATH_MODE_PROGRAM=NEVER\n)\nadd_dependencies(${COMPONENT_NAME} jerryscript_build)\n</code></pre><p>上面主要是将 JerryScript 设置为 main 组件的依赖，这样编译 main 组件时会自动编译 JerryScript。然后设置交叉编译工具链。这里需要特别注意，关闭 <code>ENABLE_LTO=OFF</code>，为什么？因为 JerryScript 里面开了此选项后，会判断编译器 ID 是否为 GNU，如果是的话，强制设置编译器为 <code>GCC</code>，导致我们的交叉编译工具链设置失效。</p>\n<p>最后，我们将编译后的静态库链接到 main 组件：</p>\n<pre class=\"prettyprint language-cmake\"><code>set(COMPONENT_BUILD_PATH ${CMAKE_BINARY_DIR}&#x2F;${COMPONENT_NAME}&#x2F;jerryscript)\n\ntarget_link_libraries(${COMPONENT_NAME}\n                      ${COMPONENT_BUILD_PATH}&#x2F;lib&#x2F;libjerry-core.a\n                      ${COMPONENT_BUILD_PATH}&#x2F;lib&#x2F;libjerry-ext.a\n                      ${COMPONENT_BUILD_PATH}&#x2F;lib&#x2F;libjerry-port-default-minimal.a)\n</code></pre><p>JerryScript 编译完后，会在编译目录的 <code>main/jerryscript</code> 下面生成最终文件，这个路径是我们上面自己指定的，我们这里只需要 <code>jerry-core.a</code> <code>jerry-ext.a</code> <code>jerry-default-minimal.a</code> 这三个静态库就行了。\n<code>${COMPONENT_NAME}</code> 就是 <code>main</code>。</p>\n<p>下面编写初始化代码，在系统启动时初始化 JerryScript 虚拟机。</p>\n<pre class=\"prettyprint language-c\"><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\n#include &quot;freertos&#x2F;FreeRTOS.h&quot;\n#include &quot;freertos&#x2F;queue.h&quot;\n#include &quot;freertos&#x2F;task.h&quot;\n\n#include &quot;jerryscript.h&quot;\n#include &quot;jerryscript-ext&#x2F;handler.h&quot;\n#include &quot;jerryscript-port.h&quot;\n\nstatic void start_jerryscript()\n{\n  &#x2F;* Initialize engine *&#x2F;\n  jerry_init(JERRY_INIT_EMPTY);\n}\n\nvoid app_main()\n{\n  &#x2F;&#x2F; init jerryscript\n  start_jerryscript();\n  while (true)\n  {\n    &#x2F;&#x2F; alive check here. but nothing to do now!\n    vTaskDelay(1000 &#x2F; portTICK_PERIOD_MS);\n  }\n  &#x2F;* Cleanup engine *&#x2F;\n  jerry_cleanup();\n}\n</code></pre><p>初始化 JerryScript 非常简单，只需要调用 <code>jerry_init(JERRY_INIT_EMPTY)</code> 就可以，现在我们已经让 js 虚拟机跑起来了。<code>vTaskDelay</code> 是 FreeRTOS 提供的函数，作用是让出指定的 cpu 时间去执行其它任务，不至于将整个应用程序阻塞在这里，<code>1000 / portTICK_PERIOD_MS</code> 表示 1000ms，这跟在 Linux 上使用 <code>sleep(1)</code> 是差不多的。<code>portTICK_PERIOD_MS</code> 表示 FreeRTOS 1ms 内执行的节拍，这跟 CPU 的频率有关，详情请参考 <a href=\"https://www.freertos.org\">FreeRTOS</a> 文档。</p>\n<p>现在 JerryScript 的集成就已经完成了，可以编译出可执行的固件了：</p>\n<pre class=\"prettyprint language-cmake\"><code>$ mkdir build\n$ cd build\n$ cmake ..\n$ make\n</code></pre><p>如果没有错误，会在编译目录生成可执行固件，使用 <code>make flash</code> 会自动将固件烧录到 ESP32 芯片上。<code>make flash</code> 不需要额外的配置，可以直接使用，它会调用内置的 <a href=\"https://github.com/espressif/esptool\">esptool.py</a> 进行烧写。</p>\n<p><strong>注意</strong></p>\n<p>烧录固件时，需要先安装串口驱动，某宝上面卖的板子质量参差不齐，型号众多，很多卖家不懂技术，自己卖的是什么都不知道。一般来说，ESP32 都是 CP2102 的驱动，去官网下载驱动就行了。</p>\n<p>具体的烧录方法请查看 nodemcujs <a href=\"https://github.com/nodemcujs/nodemcujs-firmware#4-%E7%83%A7%E5%BD%95%E5%9B%BA%E4%BB%B6\">烧录固件</a>。</p>\n<p>如果编译出错，请从头开始再来一遍。现在 JerryScript 已经跑起来了，但是我们还没有 js 代码执行，下面我们将打开串口，让从串口接收到的字符串输入给 JerryScript 执行，并且将结果从串口输出。</p>\n<pre class=\"prettyprint language-c\"><code>#include &quot;freertos&#x2F;FreeRTOS.h&quot;\n#include &quot;freertos&#x2F;queue.h&quot;\n#include &quot;freertos&#x2F;task.h&quot;\n#include &quot;driver&#x2F;uart.h&quot;\n&#x2F;&#x2F; ... 省略其它头文件\nstatic QueueHandle_t uart_queue;\nstatic void uart_event_task(void *pvParameters)\n{\n  uart_event_t event;\n  uint8_t *dtmp = (uint8_t *)malloc(1024 * 2);\n  for (;;) {\n    &#x2F;&#x2F; Waiting for UART event.\n    if (xQueueReceive(uart_queue, (void *)&amp;event, (portTickType)portMAX_DELAY)) {\n      bzero(dtmp, 1024 * 2);\n      switch (event.type) {\n      &#x2F;** \n       * We&#x27;d better handler data event fast, there would be much more data events than\n       * other types of events. If we take too much time on data event, the queue might\n       * be full.\n       *&#x2F;\n      case UART_DATA:\n        uart_read_bytes(UART_NUM_0, dtmp, event.size, portMAX_DELAY);\n        &#x2F;* Setup Global scope code *&#x2F;\n        jerry_value_t parsed_code = jerry_parse(NULL, 0, dtmp, event.size, JERRY_PARSE_NO_OPTS);\n\n        if (!jerry_value_is_error(parsed_code)) {\n          &#x2F;* Execute the parsed source code in the Global scope *&#x2F;\n          jerry_value_t ret_value = jerry_run(parsed_code);\n\n          &#x2F;* Returned value must be freed *&#x2F;\n          jerry_release_value(ret_value);\n        } else {\n          const char *ohno = &quot;something was wrong!&quot;;\n          uart_write_bytes(UART_NUM_0, ohno, strlen(ohno));\n        }\n\n        &#x2F;* Parsed source code must be freed *&#x2F;\n        jerry_release_value(parsed_code);\n        &#x2F;&#x2F; free(dtmp);\n        break;\n      &#x2F;&#x2F;Event of UART ring buffer full\n      case UART_BUFFER_FULL:\n        &#x2F;&#x2F; If buffer full happened, you should consider encreasing your buffer size\n        &#x2F;&#x2F; As an example, we directly flush the rx buffer here in order to read more data.\n        uart_flush_input(UART_NUM_0);\n        xQueueReset(uart_queue);\n        break;\n      &#x2F;&#x2F;Others\n      default:\n        break;\n      }\n    }\n  }\n  free(dtmp);\n  dtmp = NULL;\n  vTaskDelete(NULL);\n}\n\n&#x2F;**\n * Configure parameters of an UART driver, communication pins and install the driver\n * \n * - Port: UART0\n * - Baudrate: 115200\n * - Receive (Rx) buffer: on\n * - Transmit (Tx) buffer: off\n * - Flow control: off\n * - Event queue: on\n * - Pin assignment: TxD (default), RxD (default)\n *&#x2F;\nstatic void handle_uart_input()\n{\n  uart_config_t uart_config = {\n      .baud_rate = 115200,\n      .data_bits = UART_DATA_8_BITS,\n      .parity = UART_PARITY_DISABLE,\n      .stop_bits = UART_STOP_BITS_1,\n      .flow_ctrl = UART_HW_FLOWCTRL_DISABLE};\n  uart_param_config(UART_NUM_0, &amp;uart_config);\n\n  &#x2F;&#x2F;Set UART pins (using UART0 default pins ie no changes.)\n  uart_set_pin(UART_NUM_0, UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE);\n  &#x2F;&#x2F;Install UART driver, and get the queue.\n  uart_driver_install(UART_NUM_0, 1024 * 2, 1024 * 2, 20, &amp;uart_queue, 0);\n\n  &#x2F;&#x2F;Create a task to handler UART event from ISR\n  xTaskCreate(uart_event_task, &quot;uart_event_task&quot;, 1024 * 2, NULL, 12, NULL);\n}\n</code></pre><p>代码有点多，将它拆成 2 个函数来看，<code>handle_uart_input</code> 函数负责安装串口驱动，然后启动一个 <a href=\"https://www.freertos.org/taskandcr.html\">Task</a> 来处理串口输入。为什么要启动一个 task ？因为串口输入是异步的，我们不能让它阻塞，所以在新的 task 中采用 <a href=\"https://github.com/espressif/esp-idf/tree/6fe853a2c/examples/peripherals/uart/uart_events\">esp-uart-events</a> 的方式监听事件，等有串口输入的事件到来时再去读取输入并执行。</p>\n<p>板子带有一个 USB 转串口芯片，芯片的引脚被连接到 <code>UART_NUM_0</code>，所以我们可以默认从这个串口读取输入，<code>printf</code> 默认也会从这里输出，这样插上 USB 就可以当做一台 mini 的 JavaScript 开发板了，方便开发和调试。这正是动态语言在硬件编程上的魅力。</p>\n<p>有了输入，我们还需要一个 native api 用于在 JavaScript 代码中输出数据，这里我们使用自带的 <code>print</code> 就行了。在 JavaScript 代码中可以直接使用 <code>print(message)</code> 来输出数据到串口。</p>\n<pre class=\"prettyprint language-c\"><code>#include &quot;jerryscript.h&quot;\n#include &quot;jerryscript-ext&#x2F;handler.h&quot;\n\nstatic void handler_print()\n{\n  &#x2F;* Register &#x27;print&#x27; function from the extensions *&#x2F;\n  jerryx_handler_register_global ((const jerry_char_t *) &quot;print&quot;,\n                                  jerryx_handler_print);\n}\n\nvoid app_main()\n{\n  &#x2F;&#x2F; init jerryscript\n  start_jerryscript();\n  handler_print();\n  &#x2F;&#x2F; handle uart input\n  handle_uart_input();\n  while (true)\n  {\n    &#x2F;&#x2F; alive check here. but nothing to do now!\n    vTaskDelay(1000 &#x2F; portTICK_PERIOD_MS);\n  }\n  &#x2F;* Cleanup engine *&#x2F;\n  jerry_cleanup();\n}\n</code></pre><p>使用 <code>make flash</code> 编译更新后的固件，将它烧录到板子上，现在打开串口，连接上板子，输入 <code>var msg = 'hello nodemcujs'; print(msg)</code> 试试吧。你可以输入任意合法的 JavaScript 语句，使用 <code>print</code> 函数输出数据。</p>\n<p><strong>注意：不要使用 minicom，可以使用 <a href=\"https://esp8266.ru/esplorer/\">ESPlorer</a>。因为我们是将串口的输入直接输入虚拟机执行的，所以只接收可显示字符和换行回车，其它字符比如控制字符会导致执行失败</strong></p>\n<p>完整代码请查看 <a href=\"https://github.com/nodemcujs/nodemcujs-firmware\">nodemcujs</a> 源码。</p>\n<h2>2. 使用片上存储芯片：flash</h2>\n<p>上面我们已经实现了内嵌 JerryScript 虚拟机并且打通了串口交互，但每次重启都会重置数据，这显然不是一块标准的开发板，本章节我们将会对接文件系统用于存储用户数据。</p>\n<p>ESP32 已经集成了一片 4MB 的 SPI 存储芯片，SPI 是一种数据交换协议，我们这里不用太关心，感兴趣的自己查找资料，下文我们以 <code>flash</code> 代指这个存储芯片。</p>\n<p><a href=\"https://docs.espressif.com/projects/esp-idf/zh_CN/latest/index.html\">ESP-IDF</a> 工程支持 <a href=\"https://docs.espressif.com/projects/esp-idf/zh_CN/latest/api-reference/storage/spiffs.html\">spiffs</a> 组件，我们只需要拿来用就行了。要使用文件系统，有这些步骤是必须要做的：</p>\n<ol>\n<li>分区表 - 划分磁盘的用途，告诉系统有几个分区，各个分区大小是多少。每片 ESP32 的 flash 可以包含多个应用程序，以及多种不同类型的数据（例如校准数据、文件系统数据、参数存储器数据等）。因此，我们需要引入分区表的概念。</li>\n<li>mount - 读取分区表配置，如果还没有被初始化，则对磁盘进行格式化</li>\n</ol>\n<p>我们基于默认的分区表上进行修改，新增一个 data 分区用于存储用户自定义数据。在项目根目录新建 <code>partitions.csv</code> 文件，内容如下：</p>\n<pre class=\"prettyprint language-csv\"><code># Name,   Type, SubType, Offset,  Size, Flags\n# Note: if you change the phy_init or app partition offset, make sure to change the offset in Kconfig.projbuild\nnvs,      data, nvs,     0x9000,  0x6000,\nphy_init, data, phy,     0xf000,  0x1000,\nfactory,  app,  factory, 0x10000, 1M,\nstorage,  data, spiffs,  ,        0x2F0000,\n</code></pre><p><code>nvs</code> 和 <code>phy_init</code> 分区使用默认就行，<code>factory</code> 分区用于存储 App，即编译出来的可执行代码，也可以理解为编译出来的 <code>bin</code> 文件。我们指定大小为 <code>1M</code>，目前编译出来的固件大小为 <code>500KB</code> 左右，一般来说够用了。</p>\n<p><code>storage</code> 分区是我们新加的分区，用于存储用户自定义数据，<code>offset</code> 我们这里不填写，会自动对齐上一个分区。大小指定为 <code>0x2F0000</code>，差不多有 <code>2.7M</code> 可用空间。注意这是最大了，不能再大，ESP32 最常见的 flash 大小是 <code>4MB</code>，如果你的 <code>flash</code> 大小不一样，可以根据情况修改，但不能超过分区大小，可以小于。</p>\n<p>ESP32 默认将分区表数据烧写至 <code>0x8000</code> 地址处，长度为 <code>0xC00</code>，最多可以保存 <code>95</code> 个条目，分区表后面还保存有 <code>MD5</code> 校验和，所以如果你不清楚整个分区表，不要乱改分区数据。详细说明请看 <a href=\"https://docs.espressif.com/projects/esp-idf/zh_CN/latest/api-guides/partition-tables.html\">分区表</a> 文档。</p>\n<p><strong>注意</strong></p>\n<p>要使用用户自定义分区表，需要在 <code>sdkconfig</code> 文件中指定，可以使用 <code>make menuconfig</code> 图形界面，具体方法如下：</p>\n<pre class=\"prettyprint language-bash\"><code>$ mkdir build\n$ cd build\n$ cmake ..\n$ make menuconfig\n</code></pre><p>执行 <code>make menuconfig</code> 后，会出现图形界面，进入：<code>Partition Table</code>，<code>Partition Table</code> 选择 <code>Custom partition table CSV</code>。然后 <code>Custom partition CSV file</code> 填写 <code>partitions.csv</code>，注意这是你的分区表文件名，请根据你自己的情况修改。</p>\n<p>分区表制作好后，接下来我们在启动流程中 <code>mount storage</code> 分区：如果分区没有被初始化，则格式化分区后再次加载，否则直接加载。并且将使用情况打印出来。</p>\n<pre class=\"prettyprint language-c\"><code>#include &quot;esp_system.h&quot;\n#include &quot;esp_spi_flash.h&quot;\n#include &quot;esp_heap_caps.h&quot;\n#include &quot;esp_err.h&quot;\n\n#include &quot;driver&#x2F;uart.h&quot;\n#include &quot;esp_spiffs.h&quot;\n\nstatic void mount_spiffs()\n{\n  esp_vfs_spiffs_conf_t conf = {\n    .base_path = &quot;&#x2F;spiffs&quot;,\n    .partition_label = NULL,\n    .max_files = 5,\n    .format_if_mount_failed = true\n  };\n\n  esp_err_t ret = esp_vfs_spiffs_register(&amp;conf);\n\n  if (ret != ESP_OK)\n  {\n    if (ret == ESP_FAIL)\n    {\n      printf(&quot;Failed to mount or format filesystem\\n&quot;);\n    }\n    else if (ret == ESP_ERR_NOT_FOUND)\n    {\n      printf(&quot;Failed to find SPIFFS partition\\n&quot;);\n    }\n    else\n    {\n      printf(&quot;Failed to initialize SPIFFS (%s)\\n&quot;, esp_err_to_name(ret));\n    }\n    return;\n  }\n\n  size_t total = 0, used = 0;\n  ret = esp_spiffs_info(NULL, &amp;total, &amp;used);\n  if (ret != ESP_OK) {\n    printf(&quot;Failed to get SPIFFS partition information (%s)\\n&quot;, esp_err_to_name(ret));\n  } else {\n    printf(&quot;Partition size: total: %d, used: %d\\n&quot;, total, used);\n  }\n}\n</code></pre><p><code>bash_path</code> 我们设置为 <code>/spiffs</code>，这相当于根目录前缀，以后访问数据分区时都要使用 <code>/spiffs/file</code>，当然你可以根据自己情况修改。将 <code>format_if_mount_failed</code> 参数设置为 <code>true</code>，可以在分区 <code>mount 失败后自动格式化</code>，这种情况一般是分区未被格式化。注意 <a href=\"https://docs.espressif.com/projects/esp-idf/zh_CN/latest/api-reference/storage/spiffs.html\">spiffs</a> 文件系统是没有目录概念的，<code>/</code> 只是被当做一个文件名，后续我们可以自己模拟目录的概念。</p>\n<p>挂载分区后，我们就可以使用文件系统的 api 去读写文件了。我们使用 <code>esp_spiffs_info</code> 读取文件系统信息，将总大小和已使用情况打印出来。</p>\n<p>最后，在启动流程中调用这个函数：</p>\n<pre class=\"prettyprint language-c\"><code>void app_main()\n{\n  &#x2F;&#x2F; mount spiffs\n  mount_spiffs();\n  &#x2F;&#x2F; init jerryscript\n  start_jerryscript();\n  handler_print();\n  &#x2F;&#x2F; handle uart input\n  handle_uart_input();\n  while (true)\n  {\n    &#x2F;&#x2F; alive check here. but nothing to do now!\n    vTaskDelay(1000 &#x2F; portTICK_PERIOD_MS);\n  }\n  &#x2F;* Cleanup engine *&#x2F;\n  jerry_cleanup();\n}\n</code></pre><p>重新编译，然后烧写，使用串口连接上板子查看打印出来的分区信息，如果看到成功打印出分区表数据，则说明文件系统挂载成功了，如果失败了，则仔细检查一遍哪里出错了。</p>\n<h2>3. 实现 JS 文件模块</h2>\n<p>上面我们已经有了文件的概念了，那我们就可以编写 js 文件模块，然后使用 require 去加载文件模块，并且开机自动加载执行 index.js 文件，这样 JavaScript 开发者来说就可以脱离 SDK 独立开发了。当然涉及到硬件驱动部分还是需要 SDK 支持，暴露接口给 JavaScript，这里不进行细说。</p>\n<p>先来看一下 Node.js 中的文件模块长什么样：</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; a.js\nmodule.exports = function a () {\n  console.log(&#96;hello, i am ${__filename}&#96;)\n}\n</code></pre><p>这个模块很简单，只对外提供一个函数，函数里面打印出自身的文件名。那么如何使用这个模块呢：</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; index.js\nvar a = require(&#x27;.&#x2F;a.js&#x27;)\n\na()\n</code></pre><p>只需要使用 <code>require</code> 函数加载这个模块，赋值给一个变量，这个变量就引用了模块的所有对外实现。因为我们对外就暴露一个函数，所以可以直接调用。那么这里的 <code>module.exports</code> 变量是从哪里来的呢？<code>__filename</code> 又为什么会等于 <code>a.js</code> 呢？<code>require</code> 的返回值是怎么来的呢？来简单看一下 Node.js 是如何实现的。</p>\n<p>当 require 一个文件模块时，Node.js 会读取文件的内容，然后将内容头尾包装一下，最终变成：</p>\n<pre class=\"prettyprint language-js\"><code>(function (exports, require, module, __filename, __dirname) {\n  &#x2F;&#x2F; 模块源码\n})\n</code></pre><p>把参数传递进去执行这个函数，所以我们可以在文件模块中使用 exports 等未定义的变量，最后 require 函数将 exports 变量返回，就完成了一次模块的加载。当然，Node.js 中的实现是比这个要复杂很多的，这里只是简单的描述一下，详情请查看 <a href=\"https://github.com/nodejs/node/blob/master/lib/internal/modules/cjs/loader.js\">Node.js: require</a> 源码。</p>\n<p>知道了 require 是如何工作的，现在我们来实现一个最简单的 require，它只从文件系统中加载文件模块，并且不支持缓存和相对路径的。如果加载成功，则返回模块的 exports 对象，否则返回 undefined。</p>\n<p>可以新建一个 <a href=\"https://docs.espressif.com/projects/esp-idf/zh_CN/latest/api-guides/build-system.html#component-directories\">用户组件</a>，叫 jerry-module，也可以直接在 <code>main</code> 中编写。</p>\n<pre class=\"prettyprint language-c\"><code>void module_module_init()\n{\n  jerry_value_t global = jerry_get_global_object();\n\n  jerry_value_t prop_name = jerry_create_string((const jerry_char_t *)&quot;require&quot;);\n  jerry_value_t value = jerry_create_external_function(require_handler);\n  jerry_release_value(jerry_set_property(global, prop_name, value));\n  jerry_release_value(prop_name);\n  jerry_release_value(value);\n\n  jerry_release_value(global);\n}\n</code></pre><p>我们规定每个 native 模块都有一个 <code>init</code> 方法，以 <code>module</code> 开头，中间的 module 表示模块名。在 init 方法中会给 <code>global</code> 变量注册模块自身需要暴露给 JavaScript 的 api，这样 JavaScript 就可以使用了。下面是 require 函数的实现。</p>\n<pre class=\"prettyprint language-c\"><code>static jerry_value_t require_handler(const jerry_value_t func_value, &#x2F;**&lt; function object *&#x2F;\n                                     const jerry_value_t this_value, &#x2F;**&lt; this arg *&#x2F;\n                                     const jerry_value_t args[],     &#x2F;**&lt; function arguments *&#x2F;\n                                     const jerry_length_t args_cnt)  &#x2F;**&lt; number of function arguments *&#x2F;\n{\n  jerry_size_t strLen = jerry_get_string_size(args[0]);\n  jerry_char_t name[strLen + 1];\n  jerry_string_to_char_buffer(args[0], name, strLen);\n  name[strLen] = &#x27;\\0&#x27;;\n\n  size_t size = 0;\n  jerry_char_t *script = jerry_port_read_source((char *)name, &amp;size);\n\n  if (script == NULL)\n  {\n    printf(&quot;No such file: %s\\n&quot;, name);\n    return jerry_create_undefined();\n  }\n  if (size == 0)\n  {\n    return jerry_create_undefined();\n  }\n\n  jerryx_handle_scope scope;\n  jerryx_open_handle_scope(&amp;scope);\n\n  static const char *jargs = &quot;exports, module, __filename&quot;;\n  jerry_value_t res = jerryx_create_handle(jerry_parse_function((jerry_char_t *)name, strLen,\n                                          (jerry_char_t *)jargs, strlen(jargs),\n                                          (jerry_char_t *)script, size, JERRY_PARSE_NO_OPTS));\n  jerry_port_release_source(script);\n  jerry_value_t module = jerryx_create_handle(jerry_create_object());\n  jerry_value_t exports = jerryx_create_handle(jerry_create_object());\n  jerry_value_t prop_name = jerryx_create_handle(jerry_create_string((jerry_char_t *)&quot;exports&quot;));\n  jerryx_create_handle(jerry_set_property(module, prop_name, exports));\n  jerry_value_t filename = jerryx_create_handle(jerry_create_string((jerry_char_t *)name));\n  jerry_value_t jargs_p[] = { exports, module, filename };\n  jerry_value_t jres = jerryx_create_handle(jerry_call_function(res, NULL, jargs_p, 3));\n\n  jerry_value_t escaped_exports = jerry_get_property(module, prop_name);\n  jerryx_close_handle_scope(scope);\n\n  return escaped_exports;\n}\n</code></pre><p>这里我们的实现非常简单：</p>\n<ol>\n<li>require 只接收一个参数叫 <code>name</code>，表示文件模块的绝对路径。</li>\n<li>然后使用 <code>jerry_port_read_source</code> 读取文件的内容，注意使用这个函数需要头文件 <code>jerryscript-port.h</code>，使用完后记得使用 <code>jerry_port_release_source</code> 释放文件内容。</li>\n<li>接着判断文件是否存在，如果不存在或者文件内容为空，则返回 undefined，表示加载模块失败。</li>\n<li>使用 <code>jerry_parse_function</code> 构造一个 JavaScript 函数，我们这里只实现 <code>exports, module, __filename</code> 这三个参数。</li>\n<li>使用 <code>jerry_create_object</code> 构造一个 JavaScript object，使用 <code>jerry_set_property</code> 给这个 object 设置 <code>exports</code> 属性。</li>\n<li>使用 <code>jerry_call_function</code> 将 <code>exports, module, filename</code> 作为参数执行函数，这样文件模块就会执行。<code>module.exports</code> 是 <code>exports</code> 的引用。</li>\n<li>最后，在文件模块内部会赋值给 <code>exports</code> 变量，这就是模块对外暴露的 api，我们使用 <code>jerry_get_property</code> 将 <code>exports</code> 属性返回，就完成了模块加载。</li>\n</ol>\n<p>最后，我们在虚拟机初始化后，调用模块的初始化函数，将模块注册到虚拟机：</p>\n<pre class=\"prettyprint language-c\"><code>void app_main()\n{\n  &#x2F;&#x2F; mount spiffs\n  mount_spiffs();\n  &#x2F;&#x2F; init jerryscript\n  start_jerryscript();\n  handler_print();\n  &#x2F;&#x2F; handle uart input\n  handle_uart_input();\n  &#x2F;&#x2F; init node core api\n  module_module_init();\n\n  while (true)\n  {\n    &#x2F;&#x2F; alive check here. but nothing to do now!\n    vTaskDelay(1000 &#x2F; portTICK_PERIOD_MS);\n  }\n  &#x2F;* Cleanup engine *&#x2F;\n  jerry_cleanup();\n}\n</code></pre><p>现在，我们差最后一步：从文件系统中加载执行 <code>index.js</code> 文件，这样开机启动就会自动执行代码了。实现这个也很简单，在所有操作都完成后，使用文件 api 从文件系统读取 <code>index.js</code> 文件，然后使用 <code>jerry_run</code> 执行。</p>\n<pre class=\"prettyprint language-c\"><code>static void load_js_entry()\n{\n  char *entry = &quot;&#x2F;spiffs&#x2F;index.js&quot;;\n  size_t size = 0;\n  jerry_char_t *script = jerry_port_read_source(entry, &amp;size);\n  if (script == NULL) {\n    printf(&quot;No such file: &#x2F;spiffs&#x2F;index.js\\n&quot;);\n    return;\n  }\n  jerry_value_t parse_code = jerry_parse((jerry_char_t *)entry, strlen(entry), script, size, JERRY_PARSE_NO_OPTS);\n  if (jerry_value_is_error(parse_code)) {\n    printf(&quot;Unexpected error\\n&quot;);\n  } else {\n    jerry_value_t ret_value = jerry_run(parse_code);\n    jerry_release_value(ret_value);\n  }\n  jerry_release_value(parse_code);\n  jerry_port_release_source(script);\n}\n</code></pre><p>entry 的入口可以自己修改，我们指定 <code>/spiffs/index.js</code>。如果加载失败，则什么也不做。如果加载成功，则使用 <code>jerry_parse</code> 编译 js 代码，最后使用 <code>jerry_run</code> 执行。同样，在启动流程中调用这个函数。</p>\n<pre class=\"prettyprint language-c\"><code>void app_main()\n{\n  &#x2F;&#x2F; mount spiffs\n  mount_spiffs();\n  &#x2F;&#x2F; init jerryscript\n  start_jerryscript();\n  handler_print();\n  &#x2F;&#x2F; handle uart input\n  handle_uart_input();\n  &#x2F;&#x2F; init node core api\n  module_module_init();\n\n  &#x2F;&#x2F; load &#x2F;spiffs&#x2F;index.js\n  load_js_entry();\n\n  while (true)\n  {\n    &#x2F;&#x2F; alive check here. but nothing to do now!\n    vTaskDelay(1000 &#x2F; portTICK_PERIOD_MS);\n  }\n  &#x2F;* Cleanup engine *&#x2F;\n  jerry_cleanup();\n}\n</code></pre><p>现在，我们整理一下启动流程都做了什么：</p>\n<ol>\n<li>mount <a href=\"https://docs.espressif.com/projects/esp-idf/zh_CN/latest/api-reference/storage/spiffs.html\">spiffs</a> 文件系统</li>\n<li>初始化 <a href=\"https://jerryscript.net/\">JerryScript</a> 虚拟机</li>\n<li>注册全局 print 函数用于串口输出</li>\n<li>安装串口驱动，将输入传递给虚拟机执行</li>\n<li>注册 module 模块</li>\n<li>从文件系统加载 index.js 文件并执行</li>\n<li>很重要的一步：使用 <a href=\"https://www.freertos.org/a00127.html\">vTaskDelay</a> 让出 CPU 时间供其它任务执行</li>\n</ol>\n<p>至此，我们有了一个 JavaScript 开发板了，但功能有限，驱动部分以及常用的功能模块都没有实现。本来还想介绍一下 native 模块和定时器的，篇幅有限，这里就不再详细介绍了，完整的源码请查看 <a href=\"https://github.com/nodemcujs/nodemcujs-firmware\">nodemcujs</a>。</p>\n<p>最后再简单介绍一下如何上传 index.js 以及自定义数据到文件系统：</p>\n<ol>\n<li>使用 <a href=\"https://github.com/igrr/mkspiffs\">mkspiffs</a> 制作文件镜像</li>\n<li>使用 <a href=\"https://github.com/espressif/esptool\">esptool.py</a> 烧录工具将文件镜像烧录到板子</li>\n</ol>\n<p>完整的文件镜像制作和烧录方法请查看 nodemcujs <a href=\"https://github.com/nodemcujs/nodemcujs-firmware#6-%E5%88%B6%E4%BD%9C%E6%96%87%E4%BB%B6%E9%95%9C%E5%83%8F\">制作文件镜像</a>。</p>\n</div>",
	"title": "前端也能玩硬件：在ESP32上运行JavaScript",
	"last_reply_at": "2019-08-23T16:08:19.639Z",
	"good": false,
	"top": false,
	"reply_count": 2,
	"visit_count": 270,
	"create_at": "2019-08-22T05:28:10.357Z",
	"author": {
		"loginname": "LanFly",
		"avatar_url": "https://avatars1.githubusercontent.com/u/7923987?v=4&s=120"
	}
}, {
	"id": "5d5d2e64421846662d983c4c",
	"author_id": "5942903bff5813233faad8a9",
	"tab": "ask",
	"content": "<div class=\"markdown-text\"><pre class=\"prettyprint\"><code>sudo docker run -d \\\n--name gitlab-runner \\\n--restart always \\\n-v &#x2F;usr&#x2F;local&#x2F;gitlab-runner&#x2F;config:&#x2F;etc&#x2F;gitlab-runner \\\n-v &#x2F;usr&#x2F;local&#x2F;gitlab-runner&#x2F;run&#x2F;docker.sock:&#x2F;var&#x2F;run&#x2F;docker.sock \\\n-v &#x2F;usr&#x2F;local&#x2F;node&#x2F;client-admin:&#x2F;etc&#x2F;client-admin \\\ngitlab&#x2F;gitlab-runner:latest\n</code></pre><pre class=\"prettyprint\"><code>docker exec -it gitlab-runner gitlab-ci-multi-runner register \\\n  --non-interactive \\\n  --url https:&#x2F;&#x2F;gitlab.com&#x2F; \\\n  --registration-token &quot;xxxxxxxxxxx&quot; \\\n  --tag-list=ci \\\n  --description &quot;ci&quot; \\\n  --docker-pull-policy=&quot;if-not-present&quot; \\\n  --executor=docker \\\n  --docker-privileged=true \\\n  --docker-image &quot;node:10.16.3&quot; \\\n  --docker-volumes &#x2F;usr&#x2F;local&#x2F;gitlab-runner&#x2F;run&#x2F;docker.sock:&#x2F;var&#x2F;run&#x2F;docker.sock \\\n  --docker-volumes &#x2F;usr&#x2F;local&#x2F;node&#x2F;client-admin:&#x2F;etc&#x2F;client-admin\n</code></pre><p>这个是我的配置，实际项目中，无法拿到挂载目录。\n脑壳都试破了，不知道哪里出了问题。</p>\n</div>",
	"title": "卡了24小时了，有没有了解docker和gitlab-runner的大佬在？",
	"last_reply_at": "2019-08-23T15:01:31.112Z",
	"good": false,
	"top": false,
	"reply_count": 6,
	"visit_count": 421,
	"create_at": "2019-08-21T11:43:32.131Z",
	"author": {
		"loginname": "wbget",
		"avatar_url": "https://avatars0.githubusercontent.com/u/12776391?v=4&s=120"
	}
}, {
	"id": "5d54b48112a0194544416afe",
	"author_id": "5a7a5d505321b5396004ec1e",
	"tab": "share",
	"content": "<div class=\"markdown-text\"><p>一直有人问, node.js 能否做大后端，直到 nest.js 和 midwayjs 这样的框架的出现：</p>\n<p>先放张图告诉你有多火：</p>\n<p>npm 下载量：\n<img src=\"//static.cnodejs.org/FuHW0OxvaIGJnqjuEA6m45_w4806\" alt=\"image.png\"></p>\n<p><a href=\"https://www.npmtrends.com/@nestjs/core-vs-egg\">https://www.npmtrends.com/@nestjs/core-vs-egg</a></p>\n<p>star 趋势\n<img src=\"//static.cnodejs.org/FjLfsZFPc0yirehmxD2wuAskuUbv\" alt=\"image.png\"></p>\n<p>js 一时爽，重构火葬场，后端应用，可以说 typescript 是必备的，而一些纯 ts 框架对 typescript 的支持更好，并且，nest.js  和 midwayjs 这些都沿用了后端的 AOP 思想，更好地降低了耦合。\n我们使用 k8s+istio 做微服务，nest.js 作为主体框架，使用 typeorm、graphql、grpc 等技术。</p>\n<p>中文文档： <a href=\"http://docs.nestjs.cn/\">http://docs.nestjs.cn/</a>\ngithub: <a href=\"https://github.com/nestjs/nest\">https://github.com/nestjs/nest</a></p>\n<p>QQ群： 277386223</p>\n<p><img src=\"//static.cnodejs.org/FuoGtzAqQlC-z36EE4f-jE2tXo3D\" alt=\"微信图片_20190815092450.jpg\"></p>\n<p>微信群：</p>\n<p><img src=\"//static.cnodejs.org/FvcgVDg5C198bt5s9V8mZz4se0JW\" alt=\"微信图片_20190823174856.png\"></p>\n</div>",
	"title": "node.js 交流群，node.js 在后端的应用",
	"last_reply_at": "2019-08-23T10:19:26.215Z",
	"good": false,
	"top": false,
	"reply_count": 4,
	"visit_count": 756,
	"create_at": "2019-08-15T01:25:21.662Z",
	"author": {
		"loginname": "zuohuadong",
		"avatar_url": "https://avatars0.githubusercontent.com/u/11203929?v=4&s=120"
	}
}, {
	"id": "5d5fa544dcd8e81121a6087f",
	"author_id": "5b40a92e35342ab069061308",
	"tab": "ask",
	"content": "<div class=\"markdown-text\"><p>Nest.js 有社区吗? 求加入</p>\n</div>",
	"title": "Nest.js 有社区吗? 求加入",
	"last_reply_at": "2019-08-23T09:50:16.592Z",
	"good": false,
	"top": false,
	"reply_count": 1,
	"visit_count": 261,
	"create_at": "2019-08-23T08:35:16.897Z",
	"author": {
		"loginname": "Syuusuke",
		"avatar_url": "https://avatars1.githubusercontent.com/u/12440083?v=4&s=120"
	}
}, {
	"id": "5d5fad47421846662d98456c",
	"author_id": "5d5104cc697873456c6bca69",
	"tab": "share",
	"content": "<div class=\"markdown-text\"><blockquote>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93\">图数据库 - 维基百科</a>：在计算机科学中，<strong>图数据库</strong>（英语：graph database，<strong>GDB</strong>）是一个使用<a href=\"https://zh.wikipedia.org/w/index.php?title=Graph_(data_structure)&amp;action=edit&amp;redlink=1\">图结构</a>进行<a href=\"https://zh.wikipedia.org/w/index.php?title=Semantic_query&amp;action=edit&amp;redlink=1\">语义查询</a>的<a href=\"https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93\">数据库</a>，它使用<a href=\"https://zh.wikipedia.org/wiki/%E9%A1%B6%E7%82%B9_(%E5%9B%BE%E8%AE%BA)\">节点</a>、<a href=\"https://zh.wikipedia.org/wiki/%E5%9B%BE%E8%AE%BA%E6%9C%AF%E8%AF%AD\">边</a>和属性来表示和存储数据。该系统的关键概念是<strong>图</strong>，它直接将存储中的数据项，与数据<strong>节点</strong>和节点间表示关系的<strong>边</strong>的集合相关联。这些关系允许直接将存储区中的数据链接在一起，并且在许多情况下，可以通过一个操作进行检索。图数据库将数据之间的关系作为优先级。查询图数据库中的关系很快，因为它们永久存储在数据库本身中。可以使用图数据库直观地显示关系，使其对于高度互连的数据非常有用。</p>\n</blockquote>\n<blockquote>\n<p>图数据库是一种<a href=\"https://zh.wikipedia.org/wiki/NoSQL\">非关系型数据库</a>，以解决现有<a href=\"https://zh.wikipedia.org/wiki/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93\">关系数据库</a>的局限性。图模型明确地列出了数据节点之间的依赖关系，而关系模型和其他 NoSQL 数据库模型则通过隐式连接来链接数据。图数据库从设计上，就是可以简单快速地检索难以在关系系统中建模的复杂层次结构的。图数据库与 20 世纪 70 年代的网络模型数据库相似，它们都表示一般的图，但是网络模型数据库在较低的抽象层次上运行，并且不能轻松遍历一系列边。</p>\n</blockquote>\n<blockquote>\n<p>图数据库的底层存储机制可能各有不同。有些依赖于关系引擎并将图数据“存储”到表中（虽然表是一个逻辑元素，但是这种方法在图数据库、图数据库管理系统和实际存储数据的物理设备之间施加了另一层抽象）。另一些则使用<a href=\"https://zh.wikipedia.org/wiki/%E9%8D%B5%E5%80%BC%E5%AD%98%E5%84%B2\">键值存储</a>或<a href=\"https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E5%B0%8E%E5%90%91%E7%9A%84%E6%95%B8%E6%93%9A%E5%BA%AB\">面向文档的数据库</a>进行存储，使它们具有固有的 NoSQL 结构。大多数基于非关系存储引擎的图数据库还添加了<strong>标记</strong>或<strong>属性</strong>的概念，这些标记或属性本质上是具有指向另一个文档的指针的关系。这样就可以对数据元素进行分类，以便于集中检索。</p>\n</blockquote>\n<blockquote>\n<p>从图数据库中检索数据需要 <a href=\"https://zh.wikipedia.org/wiki/SQL\">SQL</a> 之外的<a href=\"https://zh.wikipedia.org/wiki/%E6%9F%A5%E8%A9%A2%E8%AA%9E%E8%A8%80\">查询语言</a>，SQL是为了处理关系系统中的数据而设计的，因此无法“优雅地”处理遍历图。截至 2017 年，没有一个像 SQL 那样通用的图查询语言，通常都是仅限与一个产品的。不过，已经有一些标准化的工作，使得 <a href=\"https://zh.wikipedia.org/wiki/Gremlin\">Gremlin</a>、<a href=\"https://zh.wikipedia.org/wiki/SPARQL\">SPARQL</a> 和 <a href=\"https://zh.wikipedia.org/w/index.php?title=Cypher_Query_Language&amp;action=edit&amp;redlink=1\">Cypher</a> 成为了多供应商查询语言。除了具有查询语言接口外，还可以通过应用程序接口（API）访问一些图数据库。</p>\n</blockquote>\n<blockquote>\n<p>图数据库与图计算引擎不同。图数据库是转换关系 <a href=\"https://zh.wikipedia.org/wiki/%E7%B7%9A%E4%B8%8A%E4%BA%A4%E6%98%93%E8%99%95%E7%90%86\">OLTP</a> 数据库的技术。而图计算引擎在 <a href=\"https://zh.wikipedia.org/wiki/%E7%B7%9A%E4%B8%8A%E5%88%86%E6%9E%90%E8%99%95%E7%90%86\">OLAP</a> 中用于批量分析。由于主要技术公司在使用专有图数据库方面的成功以及开源图数据库的引入，图数据库在 2000 年代引起了相当大的关注。</p>\n</blockquote>\n<p>上面部分引用了维基百科对图数据库的词条来讲解何为图数据库，而本文整理于图数据库 Nebula Graph 交流群中对图数据库的零碎知识，作为对图数据库知识的补充。本文分为小知识及 Q&amp;A 两部分。</p>\n<h3>本文主目录</h3>\n<ul>\n<li>小知识\n<ul>\n<li>图数据库兴起的契机</li>\n<li>图数据库存储方式 —— 基于内存存储 vs 基于分布式 kv 存储</li>\n<li>一种图数据库存储层的设计探讨</li>\n<li>图结构的可视化与 GIS 数据的可视化</li>\n</ul>\n</li>\n<li>Q&amp;A 提问回答\n<ul>\n<li>图数据库计算存储分离设计及该设计模式的考量原因</li>\n<li>怎么理解图数据库顶点和标签</li>\n<li>Nebula 如何处理 ID 冲突问题</li>\n<li>Nebula Graph 和 Tiger Graph 的区别</li>\n<li>图数据库 0 标签的意义</li>\n<li>大家怎么看「图数据库要有索引」这个问题？</li>\n<li>在知识图谱场景下计算、存储及副本一致性问题</li>\n</ul>\n</li>\n</ul>\n<h3>小知识</h3>\n<p>学习图数据库的起手式——了解图数据库兴起的契机。</p>\n<h4>🚀 图数据库兴起的契机   --@阿秾</h4>\n<p>2010 年前后，对于社交媒体网络研究的兴起带动了图计算的大规模应用。</p>\n<p>2000 年前后热门的是 <code>信息检索</code> 和 <code>分析</code> ，主要是 Google 的带动，以及 Amazon 的 e-commerce 所用的协同过滤推荐，当时 collaborative filtering也被认为是 information retrieval 的一个细分领域，包括 Google 的 PageRank 也是在信息检索领域研究较多。后来才是 Twitter，Facebook 的崛起带动了网络科学 Network science的研究。</p>\n<p>图理论和图算法不是新科学，很早就有，只是最近 20 年大数据，网络零售和社交网络的发展， <code>big data</code>、<code>social networks</code>、<code>e-commerce</code> 、<code>Web 2.0</code>让图计算有了新的用武之地，而且硬件计算力的提高和分布式计算日益成熟的支持也使图计算在高效处理海量数据成为可能。</p>\n<p>学习完图数据库发展的契机，我们来学习下图数据库存储方式和一种图数据库存储层的设计探讨。</p>\n<h4>🆚 图数据库存储方式 —— 基于内存存储 vs 基于分布式 kv 存储    –<a href=\"/user/Bruceleexiaokan\">@Bruceleexiaokan</a></h4>\n<p>Bruceleexiaokan：基于内存的图数据库有其优势，特别对于 <code>大规模深度遍历</code>以及基于之上的 <code>graph model 计算</code>，这在大规模并行处理（ MPP ）是有较强优势，其访问语言更像是编程语言而并非图遍历。</p>\n<p>Sherman：各种存储各有优缺点，各有擅长的应用场景，所以离开了场景和需求，很难对比不同的解决方案。</p>\n<p>Bruceleexiaokan：基于分布式 kv 之上的图数据库，对于大规模深度遍历和计算，对于graph model 的支持，有其缺陷。图数据库需要有分类，我们需要明白讨论的是哪一种。</p>\n<ol>\n<li>实时在线图数据库，</li>\n<li>线下图数据库，</li>\n<li>大规模数学分析用图数据库。</li>\n</ol>\n<p>如果讲到第 3 种，图结构基于内存的方案有优势。第 1 和 2 种大规模图数据库主要也就是基于 kv+ 索引</p>\n<h4>🔍 一种图数据库存储层的设计探讨   –<a href=\"/user/Bruceleexiaokan\">@Bruceleexiaokan</a></h4>\n<p>无中心化的存储集群，一般单个集群还是有一定的大小限制，不宜过大。存储层的抽象在于，数据集（图的话就是不同的点和边）到存储集群的逻辑映射对用户透明，用户可用性要求高的场景需要考虑双集群互为灾备。单集群的数据平衡是集群内部的事，集群和集群间的数据平衡是需要设计的，其中线下到线上的数据传输通道尤其重要。&lt;br /&gt;设计原则：</p>\n<ul>\n<li>不要使得单集群过大；</li>\n<li>本地互为备份集群支持读 active-active；</li>\n<li>利用线下到线上数据传输通道做好数据集群间迁移、backfill、recovery，batch update 等等工作：</li>\n<li>数据访问有抽象，使得集群的运维对于用户访问透明；</li>\n<li>做好集群间的跨数据中心数据复制；</li>\n<li>到达即使逐步投资也能线性扩展的设计；</li>\n</ul>\n<p>学习完存储和设计的小知识，来对比下图数据库图结构的可视化和 GIS 数据的可视化。</p>\n<h4>🤝 图结构的可视化与 GIS 数据的可视化  –<a href=\"/user/Space\">@Space</a></h4>\n<p>关于图结构可视化与 GIS 数据的可视化本质上有比较大的差异：</p>\n<p>GIS 是 <code>Hierarchical + 瓦片式</code>贴片展示的，而图结构本身是 flat 的，只能一次性将所有 touch 到的数据全部展示出来。但是 GIS 的做法可以给我们启示，结合具体的业务场景，能否也做一个 <code>层级抽样</code>，但是图抽样的问题是：如何在抽样的同时，尽量 <code>保留子图的连通性</code>（否则可能 high level 的层显示的都是孤立的点，只有最后最细粒度的层才会显示所有数据）。\n一些粗浅的想法：可以结合图计算的技术，先算连通子图，然后在连通子图内部算 PageRank，按照 PageRank 大小划分成不同的区间，相当于按照 PageRank 值做 Hierarchical 分层，在层次切换时，为了保证图的连通性，除了显示下一个层次的顶点（PageRank 值在下一个区间）之外，还需要显示这 2 个层次抽样出来的顶点的边（这相当于一个子图内部的连通路径的检索，如果能做 aggreate 更好，如果这些边很多，是否可以按照 EdgeType aggregate，先显示统计值，如果用户有兴趣再展开——即图数据库返回 aggregation 值，前端生成”虚拟”的边，随着进一步展开，这些”虚拟的边”会被实际明细边取代）。</p>\n<p>上述 trick 只是为了解决图数据像 GIS 一样平滑展示的问题，缺点也比较明显，Hierarchical 抽样代价高。</p>\n<p>另外，图数据的展示问题，不是一个独立的前端技术问题，还涉及到后端图数据库如下 feature 的支持：</p>\n<ol>\n<li>degree 统计</li>\n<li>按照 EdgeType 进行 aggregation</li>\n<li>query 时遇到超级顶点做截断，并返回截断信息给 client</li>\n</ol>\n<p>内置一些 AP 性算法，如 PageRank、lpa、环探测等。</p>\n<p>图数据可视化，还需要考虑：\n前端数据承载量是有限的，CS 类型的可视化工具还好点，BS 类型的可视化工具，浏览器承载的量就更少。如何在业务上将 touch 到的数据量限制在一定范围内是应用是要考虑的。\n此外，由于顶点和边的 name 和其他 tag 信息，一般在可视化的时候不会一次性都显示在图上，首次绘制可仅向图数据库请求 name，后续 tag 的 properties 在用户感兴趣的时候（点击/hover）时再次请求。</p>\n<p>布局问题：目前常见的无非是力导引、圆形、树形、网格型，这些都是无任何业务语义的布局，如树形布局，哪些应该作为顶层节点，哪些是下一级节点，如果仅仅通过边的有向性，单个 EdgeType 显示还好，多个 EdgeType 混合在一棵树上显示的时候会破坏掉单个 EdgeType 树的结构，必须引入业务规则来限制不同布局下的问题</p>\n<h3>Q&amp;A 提问回答</h3>\n<p>由于 Q&amp;A 整理于 Nebula Graph 交流群，有多人参与讨论，所以以下问题回复中会有群友昵称出现，不做 Nebula Graph 官方成员和群友身份区分，仅交流图数据库技术~如果你对下列问题有不同的看法欢迎本文评论区交流(≧▽≦)，加入图数据库交流群请加 WeChat：NebulaGraphbot</p>\n<h4>🎯 图数据库计算存储分离设计及该设计模式的考量原因</h4>\n<p>提问：计算存储分离的话，数据迁移，请问下大佬们，网络带宽会是瓶颈吗？Nebula 怎么解决的呀？</p>\n<p>恒子：现在都万兆网卡了，一般机房内很难把带宽打满的，通常 IO 会先是瓶颈。</p>\n<p>波娃子：如果是地理分布式的图数据库，带宽是要考虑的性能限制因素。</p>\n<p>Sherman：是的，现在比较流行的做法是两地三中心或者三地五中心。分布式图数据库，既有图的部分，也必然会涉及到分布系统的部分</p>\n<p>Bruceleexiaokan：由于大规模在线图数据库都设计成计算和存储分离，数据存储的设计是尤为重要。就金融 Risk 而言，逻辑上其实就是一张大图，有上百 TB 的数据量，可线性扩展的存储层设计是图数据库的关键</p>\n<p>提问：为什么都设计成计算存储分离的模式，有什么重要的考量吗</p>\n<p>Bruceleexiaokan：对于 Risk 而言，在线是 inference 为主，大部分场景是为了 feature 计算，基本在 2-3 跳以内的图遍历，都很简单，但是对于性能和可用性的要求很高，所以在线图数据库存储分离很合理。但针对数据分析的图数据库，其设计会不一样，更需要的是图的深度遍历能力，因此存储分离应该是个问题，但如何支持大规模的图，如何 scale up 应该是关键，而不是 scale out。</p>\n<p>天师：存储计算分离大多是适应云计算架构：存储层买空间，计算层买弹性虚机。</p>\n<p>吴敏：长期看，计算、存储和网络几个硬件模块发展的速度是不太一样的，并不都是摩尔定理的速度，分离能更合适长期硬件演进</p>\n<p>Sherman：我觉得存储计算分离的一个很大的好处是存储集群和计算集群可以独立扩缩容，可以通过对不同集群容量的调整，最终达到能够满足业务需求的最佳搭配。</p>\n<h4>🔖 怎么理解图数据库顶点和标签</h4>\n<p>提问：怎么理解 Vertex 和 Tag 之间的关系，Schema 里面有没有 Vertex 的概念？一个顶点 ID 可以对应多个 Tag 是这个意思吗？</p>\n<p>Sherman：解释一下 Vertex，Tag，Edge 以及他们之间的关系：</p>\n<p>Vertex 是一个顶点，用一个 64 位的 ID 来标识，一个 Vertex 可以被打上多个 Tag（标签），每个 Tag 定义了一组属性。</p>\n<p>举个例子，我们可以有 Person 和 Developer 这两个 Tag，Person 这个 Tag 里定义了姓名、电话、住址等等信息，Developer 这个 Tag 里可能定义了熟悉的编程语言、工作年限、GitHub 账号等等信息。一个 Vertex 可以被打上 Person 这个 Tag，这就表示这个 Vertex 代表了一个 Person，同时也包含了 Person 里的属性。另一个 Vertex 可能被同时打上了 Person 和 Developer 这两个 Tag，那就表示这个 Vertex 不仅是一个 Person，还是一个 Developer。</p>\n<p>Sherman：Vertex 和 Vertex 之间可以用 Edge 相连，每一条 Edge 都会有类型，比如是好友关系。每个 Edge Type 也可以定义一组属性。Edge 一般用来表示一种关系，或者一个动作。比如，Peraon A 给 Person B 转了一笔钱，那 A 和 B 之间就会有一条 transfer 类型的边，transfer 这个边类型（Edge Type）可以定义一组属性，比如转账金额，转账时间等等。</p>\n<p>Sherman：任何两个 Vertex 之间可以有多种类型的边，也可以有多条同种类型的边，比如转账，两个 Person 之间可以有多笔转账，那么每笔转账就是一条边。</p>\n<p>提问：对于例子有一个小小疑问，这里的 Tag 可以理解为本体 ontology 吗？</p>\n<p>Sherman：按我的理解，ontology 应该是整张知识图谱，也就是说包含 Vertex 和 Edge。在 Nebula 里，Vertex 本身不含内容（也就是说没有属性），内容是存放在 Tag 里的，这里“内容”指的是 ontology 里的concept，“边”就是 ontology 里的 relationship。</p>\n<p>提问：追加个问题: 多个标签是否支持层级关系，比如组织架构什么的？谢谢？</p>\n<p>在 Nebula 里，可以定义标签之间的依赖关系，比如上面的例子里，Developer 依赖 Person。</p>\n<h4>📝 Nebula 如何处理 ID 冲突问题</h4>\n<p>提问：如果要构建一个网络，用户，商家，公众号，文章，这些 ID 会重复冲突的。根据现在 vertex id就可以唯一指代点的原则，原有的 ID 不能直接使用，有什么办法构建出这个网络吗？还是把 ID 作为Tag属性，然后建索引。</p>\n<p>吴敏：类型和原始 ID 拼在一起 hash，作为 VID，然后把原始 ID 作为一个 property。</p>\n<p>Sherman：由于业务千变万化，所以当初我们决定把如何产生 VID 交个业务来决定。VID 是一个 64 位整数，在你的 case 里，如果 ID 不足 64 位，那就可以用 2-4 bit 来表示不同的类型，这样就把原来可能冲突的 ID 分到了不同的空间。如果原来的 ID 已经是 64 bit 的了，那可以像@吴敏 说的那样做 hash，把真实 ID 保存在属性里</p>\n<h4>🤔 Nebula Graph 和 Tiger Graph 的区别</h4>\n<p>提问：大佬们，我们想了解下 Nebula Graph 和 Tiger Graph有关系，二者有什么区别么</p>\n<p>Sherman：简单的讲，Tiger Graph 不是真正意义上的对等分布式，它是有中心节点的分布式，它分布存储的是点和边上的属性，但是整张图的关系必须保存在一台机器上。同时在运行的时候，整张图必须加载到内存里，这就限制了它能处理的图的规模。而一个产品的架构一旦建立之后，要改动不是一件容易的事情，基本相当于重做。</p>\n<p>J.GUARDIAN：简单理解的话，Tiger Graph 为了性能牺牲了图规模的处理能力，而 Nebula 解决的图规模的能力，但是相对会稍微牺牲一些性能。</p>\n<p>Sherman：也不完全是，当然这是我之前对 Tiger Graph 的了解。</p>\n<h4>✏️ 图数据库 0 标签的意义</h4>\n<p>提问： 我看我们的文档里写着“一个顶点必须至少有一个类型的标签”，但是我注意到 Neo4j 是支持 0 个标签的，请问没有标签的节点在查询时跟普通标签用法一样么，为什么要支持 0 个标签呢？这样做有什么意义呢？</p>\n<p>Sherman：多数的图计算性能评测的数据集（如 Graph500、Twitter）都是 0 标签，也就是无属性过滤条件。这样能看出一个图引擎的最核心的性能。通过标签过滤在大多数情况下对图进行动态剪枝，时耗进而儿会缩短。</p>\n<h4>🥅 大家怎么看「图数据库要有索引」这个问题？</h4>\n<p>提问：大家怎么看「图数据库要有索引」这个问题？</p>\n<p>Bruceleexiaokan：最终这是一个设计上的<code>trade off</code>问题，不同数据分布和不同访问需求对于不同的设计方案，性能肯定是不同的。最好的方案是设计存储访问抽象，保留设计和实现灵活性，针对不同场景可以有不同优化。</p>\n<p>相邻边的索引和节点 inline 存储本是一种优化，可以减少物理磁盘 block read 数量，和节点一块读和写。但到了一些特殊场景：</p>\n<ol>\n<li>如果更新非常频繁，会造成写放大问题</li>\n<li>单节点边出入度异常高，但访问只遍历前几个。其性能反而会变差，属性索引是另一个问题</li>\n</ol>\n<p>Sherman：<a href=\"/user/Bruceleexiaokan\">@Bruceleexiaokan</a> 完全同意，索引的使用要看场景，过度使用索引会得不偿失。</p>\n<p>提问：Nebula 是对临接点有索引的 对吧</p>\n<p>Sherman：对属性有索引</p>\n<h4>📚 在知识图谱场景下计算、存储及副本一致性问题</h4>\n<p>提问：我们知识图谱业务场景，查节点间的路径，请问下实时计算结果的效率怎么样呀？还是说比较推荐离线计算？Nebula 是存储计算分离的是吧？</p>\n<p>Sherman：说一下个人理解，我觉得知识图谱的场景一般是需要在线查询的，因为不知道会有怎么样的查询问题。嗯，是的，Nebula 是存储计算分离的，最好的好处是部署方式灵活，计算节点和存储节点可以根据不同的需求独立扩缩容。</p>\n<p>提问：各副本之间是最终一致吗？还是强一致呀？</p>\n<p>吴敏：各副本之间是基于 Raft 协议的强一致。</p>\n<h3>参考资料</h3>\n<ul>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93\">图数据库 - 维基百科</a></li>\n</ul>\n</div>",
	"title": "聊聊何为图数据库和图数据库的小知识",
	"last_reply_at": "2019-08-23T09:09:27.833Z",
	"good": false,
	"top": false,
	"reply_count": 0,
	"visit_count": 196,
	"create_at": "2019-08-23T09:09:27.833Z",
	"author": {
		"loginname": "QingZ11",
		"avatar_url": "https://avatars0.githubusercontent.com/u/38887077?v=4&s=120"
	}
}, {
	"id": "5c1c9ab676c4964062a1c3e1",
	"author_id": "5372465f3c72496d41009adc",
	"tab": "share",
	"content": "<div class=\"markdown-text\"><p>《Node.js开发实战》原书排名并发编程类榜首。有读者坐火车十小时一口气读完，欲罢不能！好不好，试读就知道。</p>\n<p><strong>62页试读下载</strong>：<a href=\"https://pan.baidu.com/s/1x3c35AmJV4rcEj_W3A1WGg\">https://pan.baidu.com/s/1x3c35AmJV4rcEj_W3A1WGg</a></p>\n<p><strong>读者热评</strong>：</p>\n<ul>\n<li>看的欲罢不能啊，火车上来回十个小时，把整体内容浏览了一遍，然后现在精读到第二张，发现学到了好多东西，好书。\n——京东读者 小***土</li>\n</ul>\n<ul>\n<li>粗略的看了一遍,准备细读一下,很多地方给详细讲了es6的新特性,包括let、const、还有class和promise,还讲解了async和await,反正不太需要有es6基础也能看得懂,不过都要2019了,其实这些应该是前端必备技能了吧.书写的很好,循序渐进,感觉前端在没搞懂node之前,其实并不需要去学py啊php啊之类的,语言毕竟只是工具,利用工具做事情的理念是想通的.(最后这句说给我自己的)\n——豆瓣读者 陈小土</li>\n</ul>\n<ul>\n<li>很不错的一本关于node的实战书！\n——京东读者 f***8</li>\n</ul>\n<ul>\n<li>内容由浅入深，引人入胜。\n——京东读者 d***t</li>\n</ul>\n<p><strong>京东有售</strong>：<a href=\"https://item.jd.com/12460185.html\">https://item.jd.com/12460185.html</a></p>\n<p><img src=\"//static.cnodejs.org/Finp2H7di-Equ_yMWsjJY6hxYGkh\" alt=\"WechatIMG148 copy.jpg\"></p>\n</div>",
	"title": "新书《Node.js开发实战》抢鲜试读",
	"last_reply_at": "2019-08-23T07:17:14.575Z",
	"good": false,
	"top": false,
	"reply_count": 28,
	"visit_count": 9500,
	"create_at": "2018-12-21T07:48:06.079Z",
	"author": {
		"loginname": "meikidd",
		"avatar_url": "https://avatars0.githubusercontent.com/u/376338?v=4&s=120"
	}
}, {
	"id": "5d5e872e421846662d984245",
	"author_id": "5c8e65d77ce0df3732428f89",
	"tab": "ask",
	"content": "<div class=\"markdown-text\"><p>如题：比如，大于，等于，模糊查询等等\nsequelize有一个原始的方法：\nconst Op = Sequelize.Op</p>\n<p>[Op.and]: {a: 5}           // AND (a = 5)\n[Op.or]: [{a: 5}, {a: 6}]  // (a = 5 OR a = 6)</p>\n<p>之前原始的查询方法找了半天终于找到了是用\nthis.app.model.query(“sql syntax”)</p>\n<p>请问在egg sequelize中怎么使用？\n十分感谢</p>\n</div>",
	"title": "Egg sequelize如何使用操作符号？",
	"last_reply_at": "2019-08-23T04:35:57.586Z",
	"good": false,
	"top": false,
	"reply_count": 9,
	"visit_count": 341,
	"create_at": "2019-08-22T12:14:38.078Z",
	"author": {
		"loginname": "oneWalker",
		"avatar_url": "https://avatars1.githubusercontent.com/u/18098166?v=4&s=120"
	}
}, {
	"id": "5d5e4eec421846662d9840c1",
	"author_id": "5b56d03a2860af042a21783e",
	"tab": "ask",
	"content": "<div class=\"markdown-text\"><p>有大佬,\n可以分享下egg集成好用的api文档管理工具嘛.</p>\n</div>",
	"title": "egg 可集成那些api文档工具",
	"last_reply_at": "2019-08-23T02:54:50.530Z",
	"good": false,
	"top": false,
	"reply_count": 2,
	"visit_count": 507,
	"create_at": "2019-08-22T08:14:36.641Z",
	"author": {
		"loginname": "Goomly",
		"avatar_url": "https://avatars1.githubusercontent.com/u/40434024?v=4&s=120"
	}
}, {
	"id": "5d5e6af1421846662d9841be",
	"author_id": "58cb34c8246a2aeb194a5489",
	"tab": "share",
	"content": "<div class=\"markdown-text\"><h3><code>transform stream</code></h3>\n<p><code>through2</code> 是一个 <code>transform stream</code> 的封装库，用来处理 <code>node</code> 的 <code>stream</code>，源码虽然仅仅只有100多行，但是里面的内容确实很有看头的！</p>\n<h4><code>Transform</code> 概念</h4>\n<p><code>Transform</code> 是一个变换流，既可读也可写 是双工流 <code>Duplex</code> 的特殊形式。<code>Duplex</code> 的写和读没有任何关联，两个缓冲区和管道互不干扰，而 <code>Transform</code> 将其输入和输出是存在相互关联，通过转换函数将流进行转换。</p>\n<h4><code>transform stream</code> 简单案例</h4>\n<p>实现一个用来将目标字符串替换成指定字符串的变换流：</p>\n<pre class=\"prettyprint language-js\"><code>\n&#x2F;&#x2F; replaceStream.ts\n\nimport { Transform } from &quot;stream&quot;;\n\nexport default class ReplaceStream extends Transform {\n  constructor(\n    private searchString: string,\n    private replaceString: string,\n    private tailPiece: string = &quot;&quot;\n  ) {\n    super();\n  }\n  _transform(chunk, encoding, callback) {\n    const pieces = (this.tailPiece + chunk).split(this.searchString);\n    const lastPiece = pieces[pieces.length - 1];\n    const tailPieceLen = this.searchString.length - 1;\n\n    this.tailPiece = lastPiece.slice(-tailPieceLen);\n    pieces[pieces.length - 1] = lastPiece.slice(0, -tailPieceLen);\n    this.push(pieces.join(this.replaceString));\n\n    callback();\n  }\n\n  &#x2F;**\n  某些情况下，转换操作可能需要在流的末尾发送一些额外的数据。\n  *&#x2F;\n  _flush(callback) {\n    this.push(this.tailPiece);\n    this.push(&quot;\\n&quot;)\n    this.push(&quot;haha&quot;)\n    callback();\n  }\n}\n\n\n&#x2F;&#x2F; replaceStreamTest.ts\n\nimport ReplaceStream from &quot;.&#x2F;replaceStream&quot;;\n\nconst re = new ReplaceStream(&quot;World&quot;, &quot;Nodejs&quot;);\n\nre.on(&quot;data&quot;, chunk =&gt; console.log(chunk.toString()));\n\nre.write(&quot;hello w&quot;);\nre.write(&quot;orld&quot;);\nre.end();\n\n</code></pre><p>创建一个新的类并继承 <code>stream.Transform</code> 这个基类。该类的构造函数接受两个参数：<code>searchString</code> 和 <code>replaceString</code>。这两个参数用于指定需要查找匹配的字符串以及用来替换的字符串。同时还初始化了一个内部变量 <code>tailPieceLen</code> 提供给 <code>_transform()</code> 方法使用。</p>\n<p><code>_transform()</code> 方法和 <code>_write()</code> 方法有相同的方法签名，但并不是将数据直接写到底层资源，而是使用 <code>this.push()</code> 方法将其推送到内部缓存，就像我们在可读流 <code>_read()</code> 方法中做的一样。这就说明了变换流中的两部分事实上被连接起来。</p>\n<p><code>_flush()</code> 方法只接受一个回调函数作为参数，必须确保在所有操作完成之后调用它，使流终结。</p>\n<h3><code>through2</code> 核心源码解读</h3>\n<p><code>through2.js</code> 是 <code>Transform stream</code> 的简单封装库，用起来非常简单，下面来看下它的核心代码。</p>\n<pre class=\"prettyprint language-js\"><code>function through2 (construct) {\n  return function throughHOC (options, transform, flush) {\n    if (typeof options == &#x27;function&#x27;) {\n      flush     = transform\n      transform = options\n      options   = {}\n    }\n\n    if (typeof transform != &#x27;function&#x27;)\n      transform = noop\n\n    if (typeof flush != &#x27;function&#x27;)\n      flush = null\n\n    return construct(options, transform, flush)\n  }\n}\n</code></pre><p>这是段工厂函数，<code>through2.js</code> 的三个 <code>api</code> 都是由这个方法生成的。</p>\n<p>同时 <code>through2</code> 也是一个高阶函数，接收一个参数，这个参数 <code>construct</code> 是一个函数，在这个项目中这个形参将有三个实参，也就是对应的三个 <code>API</code>。</p>\n<p><code>through2</code> 也返回一个高阶函数，为了能更好的认识这个函数，命名为 <code>throughHOC</code>， 它有三个形式参数：</p>\n<ul>\n<li><code>options</code>   <code>Transform</code> 类的实例参数</li>\n<li><code>transform</code> 实际转换函数</li>\n<li><code>flush</code>     方法只接受一个回调函数作为参数，必须确保在所有操作完成之后调用它，使流终结</li>\n</ul>\n<p>函数 <code>throughHOC</code> 内部对参数做了一些整理：</p>\n<ul>\n<li>如果 <code>options</code> 是一个 <code>function</code> ，那这个 <code>options</code> 就是转换函数，<code>options</code> 则会是一个默认值；</li>\n<li>如果 <code>options</code> 存在且 <code>transform</code> 不是一个 <code>function</code> ，那 <code>transform</code> 就被重置为默认转换函数；</li>\n<li>如果 <code>flush</code> 不是一个 <code>function</code> ，则重置为 <code>null</code></li>\n</ul>\n<p>参数整理完了，就把它们作为参数，传入 <code>construct</code> 函数内。这个 <code>construct</code> 就是实现三个 <code>API</code> 的方法。</p>\n<p>说 <code>API</code> 方法之前，先说下 <code>Transform</code> 类的加工 – <code>DestroyableTransform</code>：</p>\n<pre class=\"prettyprint language-js\"><code>function DestroyableTransform(opts) {\n  Transform.call(this, opts)\n  this._destroyed = false\n}\n\ninherits(DestroyableTransform, Transform)\n\nDestroyableTransform.prototype.destroy = function(err) {\n  if (this._destroyed) return\n  this._destroyed = true\n  \n  var self = this\n  process.nextTick(function() {\n    if (err)\n      self.emit(&#x27;error&#x27;, err)\n    self.emit(&#x27;close&#x27;)\n  })\n}\n</code></pre><p><code>DestroyableTransform</code> 继承 <code>Transform</code> ，实现了 <code>destroy</code> 方法，当触发了 <code>destroy</code> 后，需要手动触发 <code>close</code> 事件。</p>\n<p>下面就来说下实现三个 <code>API</code> 的函数：</p>\n<blockquote>\n<p>主方法</p>\n</blockquote>\n<pre class=\"prettyprint language-js\"><code>\nlet construct = function (options, transform, flush) {\n  var t2 = new DestroyableTransform(options)\n\n  t2._transform = transform\n\n  if (flush)\n    t2._flush = flush\n\n  return t2\n}\n\nmodule.exports = through2(construct)\n</code></pre><p>上面说过了 <code>through2</code> 函数，它的参数就是上面的 <code>construct</code> 函数，首先 实例化 <code>DestroyableTransform</code> 这个类，<code>options</code> 就是通过外部传入的配置参数，接下来就是重新实现了 <code>_transform</code> 和 <code>_flush</code> 这两个方法。</p>\n<blockquote>\n<p><code>through2.obj</code></p>\n</blockquote>\n<p>这个 <code>API</code> 和主方法唯一的区别就是开启了对象模式，将 <code>objectMode</code> 属性设置为 <code>true</code>，<code>highWaterMark</code> 属性设置为 <code>16</code></p>\n<pre class=\"prettyprint language-js\"><code>var t2 = new DestroyableTransform(Object.assign({ objectMode: true, highWaterMark: 16 }, options))\n</code></pre><blockquote>\n<p><code>through2.ctor</code></p>\n</blockquote>\n<p>这个 <code>API</code> 返回的是 <code>DestroyableTransform</code> 的子类，并不是 <code>Transform stream</code> 的实例，这个在使用的时候其实和主方法唯一的区别就是需要额外实例化这个 <code>API</code> 返回值。</p>\n<pre class=\"prettyprint language-js\"><code>\nlet construct = function (options, transform, flush) {\n  function Through2 (override) {\n    if (!(this instanceof Through2))\n      return new Through2(override)\n\n    this.options = Object.assign({}, options, override)\n\n    DestroyableTransform.call(this, this.options)\n  }\n\n  inherits(Through2, DestroyableTransform)\n\n  Through2.prototype._transform = transform\n\n  if (flush)\n    Through2.prototype._flush = flush\n\n  return Through2\n}\n\nmodule.exports.ctor = through2(construct)\n</code></pre><p>使用：</p>\n<pre class=\"prettyprint language-js\"><code>const through2 = require(&#x27;through2&#x27;)\nconst Ctor = through2.ctor(function(chunk, enc, callback) {\n  console.log(&#x27;chunk&#x27;, chunk.toString());\n  callback(null, chunk);\n});\nconst th2 = new Ctor();\n</code></pre><h3><code>through2</code> 使用 <code>typescript</code> 重构</h3>\n<p>不得不感叹这个项目的厉害之处，仅仅只是对 <code>Transform</code> 做了一层简单的封装，却透出了很多内容，项目中虽然只是额外扩展了两个 <code>api</code>，但是熟悉源码之后就可以对它做更多的扩展了。这也不得不说转换流 <code>Transform</code> 的强大之处。</p>\n<p>在学习源码之后，用 <code>typescript</code> 重构了一下，对代码更加的清晰，有了更多的认识，值得好好学习。</p>\n<p>源码地址–<a href=\"https://github.com/soraping/through2-ts\">through2-ts</a></p>\n</div>",
	"title": "through2源码学习及ts版",
	"last_reply_at": "2019-08-23T02:14:59.589Z",
	"good": false,
	"top": false,
	"reply_count": 3,
	"visit_count": 429,
	"create_at": "2019-08-22T10:14:09.694Z",
	"author": {
		"loginname": "soraping",
		"avatar_url": "https://avatars2.githubusercontent.com/u/8610213?v=4&s=120"
	}
}, {
	"id": "5d5e70aadcd8e81121a60540",
	"author_id": "5cc546de37faec0ce1d0790a",
	"tab": "share",
	"content": "<div class=\"markdown-text\"><p><img src=\"https://user-gold-cdn.xitu.io/2019/8/22/16cb86875d7d2c30?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"ä¸ä¸ªåè´¹çå¨çº¿è¡¨æ ¼è½¬æ¢å·¥å·ââTableConvert\"></p>\n<p>TableConvert 是一个可以在线转换表格的工具，支持 Markdown 表格、CSV、JSON、XML、YAML、SQL、HTML 表格、Excel 和 LaTeX 表格，并且还内嵌了一个表格编辑器，像微软的 Excel 一样编辑，使用非常方便。</p>\n<h3>功能列表</h3>\n<ul>\n<li>转换，编辑和生成 Markdown 表格、CSV、JSON、XML、YAML、SQL、HTML 表格、Excel 和 LaTeX 表格</li>\n<li>可视化表格创建器</li>\n<li>类似于 Excel 的表格编辑器，同时支持键盘和鼠标操作</li>\n<li>提取网址中的表格</li>\n<li>LaTex table 生成器</li>\n<li>自定义输出模板（IDEA）</li>\n<li>压缩 XML、JSON、HTML 等</li>\n</ul>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/8/22/16cb868758fecb3d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"ä¸ä¸ªåè´¹çå¨çº¿è¡¨æ ¼è½¬æ¢å·¥å·ââTableConvert\"></p>\n<p>网站截图</p>\n<h3>支持的转换格式</h3>\n<p>Excel 转换器</p>\n<ul>\n<li>将 Excel 转换为 Markdown 表格</li>\n<li>将 Excel 转换为 CSV/TSV</li>\n<li>将 Excel 转换为 JSON</li>\n<li>将 Excel 转换为 XML</li>\n<li>将 Excel 转换为 YAML</li>\n<li>将 Excel 转换为 create 表格 SQL and insert SQL</li>\n<li>将 Excel 转换为 HTML 表格</li>\n<li>将 Excel 转换为 LaTex 表格</li>\n<li>将 Excel 转换为 Plain Text 表格</li>\n</ul>\n<p>URL 转换器</p>\n<ul>\n<li>将 URL 转换为 Markdown 表格</li>\n<li>将 URL 转换为 CSV/TSV</li>\n<li>将 URL 转换为 JSON</li>\n<li>将 URL 转换为 XML</li>\n<li>将 URL 转换为 YAML</li>\n<li>将 URL 转换为 create 表格 SQL and insert SQL</li>\n<li>将 URL 转换为 HTML 表格</li>\n<li>将 URL 转换为 Excel</li>\n<li>将 URL 转换为 LaTex 表格</li>\n<li>将 URL 转换为 Plain Text 表格</li>\n</ul>\n<p>HTML 表格转换器</p>\n<ul>\n<li>将 HTML 转换为 Markdown 表格</li>\n<li>将 HTML 转换为 CSV/TSV</li>\n<li>将 HTML 转换为 JSON</li>\n<li>将 HTML 转换为 XML</li>\n<li>将 HTML 转换为 YAML</li>\n<li>将 HTML 转换为 create 表格 SQL and insert SQL</li>\n<li>将 HTML 转换为 Excel</li>\n<li>将 HTML 转换为 LaTex 表格</li>\n<li>将 HTML 转换为 Plain Text 表格</li>\n</ul>\n<p>Markdown 表格转换器</p>\n<ul>\n<li>将 Markdown 转换为 CSV/TSV</li>\n<li>将 Markdown 转换为 JSON</li>\n<li>将 Markdown 转换为 XML</li>\n<li>将 Markdown 转换为 YAML</li>\n<li>将 Markdown 转换为 create 表格 SQL and insert SQL</li>\n<li>将 Markdown 表格转换为 HTML 表格</li>\n<li>将 Markdown 转换为 Excel</li>\n<li>将 Markdown 转换为 LaTex 表格</li>\n<li>将 Markdown 转换为 Plain Text 表格</li>\n</ul>\n<p>CSV/TSV 转换器</p>\n<ul>\n<li>将 CSV 转换为 Markdown 表格</li>\n<li>将 CSV 转换为 JSON</li>\n<li>将 CSV 转换为 XML</li>\n<li>将 CSV 转换为 YAML</li>\n<li>将 CSV 转换为 create 表格 SQL and insert SQL</li>\n<li>将 CSV 表格转换为 HTML 表格</li>\n<li>将 CSV 转换为 Excel</li>\n<li>将 CSV 转换为 LaTex 表格</li>\n<li>将 CSV 转换为 Plain Text 表格</li>\n</ul>\n<p>JSON 转换器</p>\n<ul>\n<li>将 JSON 转换为 Markdown 表格</li>\n<li>将 JSON 转换为 XML</li>\n<li>将 JSON 转换为 YAML</li>\n<li>将 JSON 转换为 create 表格 SQL and insert SQL</li>\n<li>将 JSON 表格转换为 HTML 表格</li>\n<li>将 JSON 转换为 Excel</li>\n<li>将 JSON 转换为 LaTex 表格</li>\n<li>将 JSON 转换为 Plain Text 表格</li>\n</ul>\n<h3>如何使用</h3>\n<p>下面以 Excel 转换成 Markdown 表格为例</p>\n<p><strong>步骤1.</strong> 打开 TableConvert，单击菜单栏中的<code>Import</code>按钮，切换到<code>Excel</code>选项卡。在导入窗口中，你可以看到如下提示：</p>\n<blockquote>\n<p>Paste your cells from Excel, Numbers, Google Docs or Browser table</p>\n</blockquote>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/8/22/16cb86875ddabc45?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"ä¸ä¸ªåè´¹çå¨çº¿è¡¨æ ¼è½¬æ¢å·¥å·ââTableConvert\"></p>\n<p><strong>步骤2.</strong> 如上所述，从 Excel（或其他电子表格程序）复制一系列单元格并将其粘贴到文本框中，单击<code>Import data</code>按钮。</p>\n<p><strong>步骤3.</strong> 现在，从 Excel 复制的内容已导入网站并自动转换为 Markdown 表格，你只需要确保在输出区域中选择的选项卡是<code>Markdown</code>。</p>\n<p>单击<code>Copy</code>按钮将结果复制到剪贴板。单击<code>Dowuload</code>按钮将 Markdown 文件下载到本地。拿到对应 Excel 表格的 Markdown 后，可以直接在文档中使用该文本。</p>\n<p>网站名称：TableConvert<br>\n链接地址：<a href=\"https://tableconvert.com\">tableconvert.com/</a></p>\n</div>",
	"title": "分享一个免费的在线表格转换工具 - TableConvert",
	"last_reply_at": "2019-08-23T01:20:46.330Z",
	"good": false,
	"top": false,
	"reply_count": 1,
	"visit_count": 407,
	"create_at": "2019-08-22T10:38:34.257Z",
	"author": {
		"loginname": "Fechin",
		"avatar_url": "https://avatars2.githubusercontent.com/u/2541482?v=4&s=120"
	}
}, {
	"id": "5d5ccaede79eaa6628beb2e8",
	"author_id": "5c8e65d77ce0df3732428f89",
	"tab": "ask",
	"content": "<div class=\"markdown-text\"><p><strong>关键字</strong>：<strong>egg扩展,helper</strong>\n<strong>背景</strong>：egg框架中extend下可以扩展框架里面的东西，包括helper.js, application.js等等。但是指定的命名方式为Helper。\n<strong>问题</strong>：自己在使用中会使用很多helper函数，在这个过程中helper.js的单个文件会越来越大，且不同类别的方法放在同一个file里面会使得框架越来越大，如何分成多个helper文件呢？网上找了半天没有找到。</p>\n</div>",
	"title": "egg中如何定义多个helper扩展文件？",
	"last_reply_at": "2019-08-23T01:19:18.386Z",
	"good": false,
	"top": false,
	"reply_count": 15,
	"visit_count": 646,
	"create_at": "2019-08-21T04:39:09.771Z",
	"author": {
		"loginname": "oneWalker",
		"avatar_url": "https://avatars1.githubusercontent.com/u/18098166?v=4&s=120"
	}
}, {
	"id": "5d5e9ab6421846662d984288",
	"author_id": "5d5218a412a01945444162a9",
	"tab": "ask",
	"content": "<div class=\"markdown-text\"><blockquote>\n<p>“scripts”: {\n“start”: “egg-scripts start --port=7001 --env=prod --daemon --title=egg-server-zhuzuo-app-api-v1-prod”,\n“stop”: “egg-scripts stop --title=egg-server-zhuzuo-app-api-v1-prod”,\n“start-test”: “egg-scripts start --port=7002 --env=test --daemon --title=egg-server-zhuzuo-app-api-v1-test”,\n“stop-test”: “egg-scripts stop --title=egg-server-zhuzuo-app-api-v1-test”\n\t},</p>\n</blockquote>\n<pre class=\"prettyprint\"><code>启动脚本是这样的，我想在一台服务器上不同的端口，部署不同的环境，7002部署测试环境，然后我用命令：npm run start-test，启动失败，不知道为啥。\n</code></pre><blockquote>\n<p>[root<a href=\"/user/VM_0_8_centos\">@VM_0_8_centos</a> test]# npm run start-test</p>\n</blockquote>\n<blockquote>\n<p>zhuzuo-app-api-v1@1.0.0 start-test /srv/www/zhuzuoapp/api/v1/test\negg-scripts start --port=7002 --env=test --daemon --title=egg-server-zhuzuo-app-api-v1-test</p>\n</blockquote>\n<p>[egg-scripts] Starting egg application at /srv/www/zhuzuoapp/api/v1/test\n[egg-scripts] Run node /srv/www/zhuzuoapp/api/v1/test/node_modules/egg-scripts/lib/start-cluster {“port”:7002,“title”:“egg-server-zhuzuo-app-api-v1-test”,“baseDir”:&quot;/srv/www/zhuzuoapp/api/v1/test&quot;,“framework”:&quot;/srv/www/zhuzuoapp/api/v1/test/node_modules/egg&quot;} --title=egg-server-zhuzuo-app-api-v1-test\n[egg-scripts] Save log file to /root/logs\n[egg-scripts] Wait Start: 1…\n[egg-scripts] Wait Start: 2…\n[egg-scripts] tail -n 100 /root/logs/master-stderr.log\n[egg-scripts] Got error when startup:\n[egg-scripts] 2019-08-22 21:31:00,909 ERROR 26377 [app_worker] server got error: bind EADDRINUSE null:7002, code: EADDRINUSE\n[egg-scripts] 2019-08-22 21:31:00,921 ERROR 26356 nodejs.AppWorkerDiedError: [master] app_worker#1:26377 died (code: 0, signal: null, suicide: false, state: dead), current workers: [“2”]\n[egg-scripts]     at Master.onAppExit (/srv/www/zhuzuoapp/api/v1/test/node_modules/egg-cluster/lib/master.js:510:21)\n[egg-scripts]     at Master.emit (events.js:203:13)\n[egg-scripts]     at Messenger.sendToMaster (/srv/www/zhuzuoapp/api/v1/test/node_modules/egg-cluster/lib/utils/messenger.js:137:17)\n[egg-scripts]     at Messenger.send (/srv/www/zhuzuoapp/api/v1/test/node_modules/egg-cluster/lib/utils/messenger.js:102:12)\n[egg-scripts]     at EventEmitter.&lt;anonymous&gt; (/srv/www/zhuzuoapp/api/v1/test/node_modules/egg-cluster/lib/master.js:353:22)\n[egg-scripts]     at EventEmitter.emit (events.js:208:15)\n[egg-scripts]     at ChildProcess.&lt;anonymous&gt; (internal/cluster/master.js:188:13)\n[egg-scripts]     at Object.onceWrapper (events.js:291:20)\n[egg-scripts]     at ChildProcess.emit (events.js:203:13)\n[egg-scripts]     at Process.ChildProcess._handle.onexit (internal/child_process.js:272:12)\n[egg-scripts] name: “AppWorkerDiedError”\n[egg-scripts] pid: 26356\n[egg-scripts] hostname: VM_0_8_centos\n[egg-scripts]\n[egg-scripts] 2019-08-22 21:31:00,921 ERROR 26356 [master] app_worker#1:26377 start fail, exiting with code:1\n[egg-scripts] 2019-08-22 21:31:00,922 ERROR 26356 [master] exit with code:1\n[egg-scripts] 2019-08-22 21:31:00,928 ERROR 26364 [agent_worker] receive disconnect event on child_process fork mode, exiting with code:110\n[egg-scripts] 2019-08-22 21:31:00,930 ERROR 26364 [agent_worker] exit with code:110\n[egg-scripts] 2019-08-22 21:31:01,010 ERROR 26383 [app_worker] exit with code:1\n[egg-scripts] events.js:180\n[egg-scripts]       throw er; // Unhandled ‘error’ event\n[egg-scripts]       ^\n[egg-scripts]\n[egg-scripts] Error: write EPIPE\n[egg-scripts]     at process.target._send (internal/child_process.js:806:20)\n[egg-scripts]     at process.target.send (internal/child_process.js:676:19)\n[egg-scripts]     at Object.&lt;anonymous&gt; (/srv/www/zhuzuoapp/api/v1/test/node_modules/egg-cluster/lib/app_worker.js:28:9)\n[egg-scripts]     at Module._compile (internal/modules/cjs/loader.js:868:30)\n[egg-scripts]     at Object.Module._extensions…js (internal/modules/cjs/loader.js:879:10)\n[egg-scripts]     at Module.load (internal/modules/cjs/loader.js:731:32)\n[egg-scripts]     at Function.Module._load (internal/modules/cjs/loader.js:644:12)\n[egg-scripts]     at Function.Module.runMain (internal/modules/cjs/loader.js:931:10)\n[egg-scripts]     at internal/main/run_main_module.js:17:11\n[egg-scripts] Emitted ‘error’ event at:\n[egg-scripts]     at process.&lt;anonymous&gt; (internal/cluster/worker.js:27:12)\n[egg-scripts]     at process.emit (events.js:203:13)\n[egg-scripts]     at internal/child_process.js:810:39\n[egg-scripts]     at processTicksAndRejections (internal/process/task_queues.js:75:11) {\n[egg-scripts]   errno: ‘EPIPE’,\n[egg-scripts]   code: ‘EPIPE’,\n[egg-scripts]   syscall: ‘write’\n[egg-scripts] }\n[egg-scripts]\n[egg-scripts] Start got error, see /root/logs/master-stderr.log\n[egg-scripts] Or use <code>--ignore-stderr</code> to ignore stderr at startup.\nnpm ERR! code ELIFECYCLE\nnpm ERR! errno 1\nnpm ERR! zhuzuo-app-api-v1@1.0.0 start-test: <code>egg-scripts start --port=7002 --env=test --daemon --title=egg-server-zhuzuo-app-api-v1-test</code>\nnpm ERR! Exit status 1\nnpm ERR!\nnpm ERR! Failed at the zhuzuo-app-api-v1@1.0.0 start-test script.\nnpm ERR! This is probably not a problem with npm. There is likely additional logging output above.</p>\n<p>npm ERR! A complete log of this run can be found in:\nnpm ERR!     /root/.npm/_logs/2019-08-22T13_31_02_057Z-debug.log</p>\n<p>这是给出的错误提示，哪位大佬帮忙看一下，感谢。</p>\n</div>",
	"title": "egg js 启动失败",
	"last_reply_at": "2019-08-23T00:52:39.542Z",
	"good": false,
	"top": false,
	"reply_count": 1,
	"visit_count": 245,
	"create_at": "2019-08-22T13:37:58.269Z",
	"author": {
		"loginname": "wuyugege",
		"avatar_url": "https://avatars0.githubusercontent.com/u/11754341?v=4&s=120"
	}
}, {
	"id": "5c1c425c76c4964062a1c0ef",
	"author_id": "5c1c411f76c4964062a1c0e3",
	"tab": "share",
	"content": "<div class=\"markdown-text\"><p>推荐一个前端导航网站，记录了各种关于前端的网址，可以直接在对应社区查找问题。\n喜欢的话赶快收藏一波吧 ^^\n网站地址： <strong><a href=\"https://www.frontendjs.com/\">https://www.frontendjs.com/</a></strong></p>\n<p><img src=\"//static.cnodejs.org/Fk1zwq8EO9Ugzovv-D1T5-GUnuIy\" alt=\"3898986698-5c05daee066b9_articlex.png\"></p>\n</div>",
	"title": "前端导航网址分享，觉得有帮助的可以收藏下",
	"last_reply_at": "2019-08-22T14:44:22.489Z",
	"good": false,
	"top": false,
	"reply_count": 23,
	"visit_count": 3669,
	"create_at": "2018-12-21T01:31:08.779Z",
	"author": {
		"loginname": "bestvist",
		"avatar_url": "https://avatars2.githubusercontent.com/u/22828569?v=4&s=120"
	}
}, {
	"id": "5b7ac9c7c52ad1482eb940bf",
	"author_id": "5b52cbf1fb9e84ec69cc1ca2",
	"tab": "ask",
	"content": "<div class=\"markdown-text\"><p>Egg.js现在用的人多吗？那些公司在用有知道的吗？</p>\n<p>同上，老铁们出来吧。</p>\n</div>",
	"title": "Egg.js现在用的人多吗？那些公司在用有知道的吗？",
	"last_reply_at": "2019-08-22T12:24:35.674Z",
	"good": false,
	"top": false,
	"reply_count": 137,
	"visit_count": 21225,
	"create_at": "2018-08-20T14:01:43.981Z",
	"author": {
		"loginname": "nodeper",
		"avatar_url": "https://avatars2.githubusercontent.com/u/41500847?v=4&s=120"
	}
}, {
	"id": "5d5e15b2421846662d983f2b",
	"author_id": "5d5e1523e79eaa6628beb75e",
	"tab": "share",
	"content": "<div class=\"markdown-text\"><p>不相信node的性能好？看看google的测试报告再说。\n咋一看数据，go比node好，但要知道，node可是脚本语言，而go的性能跟c差不多的，其他语言python、php跟go是十倍百倍的差距。</p>\n<p>在实际项目中，结合node天生异步的程序结构，谁的性能更好就说不定了。</p>\n<p><img src=\"//static.cnodejs.org/Fqh0rmZxA5FMbVZCxrzob4UYi06f\" alt=\"WX20190822-115515.png\">\n<img src=\"//static.cnodejs.org/FohpRhr0S7fNuYe33IdPRa874e8_\" alt=\"WX20190822-115620.png\"></p>\n</div>",
	"title": "nodejs 与golang的性能对比",
	"last_reply_at": "2019-08-22T11:57:43.801Z",
	"good": false,
	"top": false,
	"reply_count": 5,
	"visit_count": 938,
	"create_at": "2019-08-22T04:10:26.078Z",
	"author": {
		"loginname": "linewei",
		"avatar_url": "https://avatars0.githubusercontent.com/u/10016493?v=4&s=120"
	}
}, {
	"id": "591168c39e32cc84569a6cc5",
	"author_id": "53b25565399ed9e07d1e8793",
	"tab": "ask",
	"content": "<div class=\"markdown-text\"><p>比如表blog里有个user引用</p>\n<pre class=\"prettyprint language-js\"><code>new Schema({\n\ttitle: {\n\t\ttype: String,\n\t\tunique: true\n\t},\n\tcontent: String,\n\tin_time: {\n\t\ttype: Date,\n\t\tdefault: Date.now\n\t},\n\tuser: {\n\t\ttype: Schema.Types.ObjectId,\n\t\tref: &#x27;user&#x27;\n\t}\n});\n</code></pre><p>user里有个字段是isDelete</p>\n<pre class=\"prettyprint language-js\"><code>new Schema({\n\tisDelete: {type: Boolean, default: false}\n});\n</code></pre><p>现在我想在查询的时候对user进行筛选，user状态为删除的（isDelete: true) 博客不要查询出来</p>\n<pre class=\"prettyprint language-js\"><code>Blog.find({}).populate({\n\tpath: &#x27;user&#x27;,\n\tmatch: {isDelete: false}\n}).exec()\n</code></pre><p>这样查询出来的数据还是全部的博客，但用户被删除的博客里的user字段没数据了</p>\n<p>我想要的是用户被删除了的博客直接就不要被查询出来了，这样的需求mongoose可以实现吗？</p>\n</div>",
	"title": "mongoose查询可以以populate里的条件对要查询的表进行筛选吗？",
	"last_reply_at": "2019-08-22T10:11:13.166Z",
	"good": false,
	"top": false,
	"reply_count": 19,
	"visit_count": 5672,
	"create_at": "2017-05-09T06:59:15.726Z",
	"author": {
		"loginname": "tomoya92",
		"avatar_url": "https://avatars2.githubusercontent.com/u/6915570?v=4&s=120"
	}
}, {
	"id": "5b101b058a4f51e140d9440c",
	"author_id": "5b094f5257137f22415c4685",
	"tab": "ask",
	"content": "<div class=\"markdown-text\"><p>本文推荐中国能用的2个VPN翻墙软件，顺便介绍代理翻墙方法：蓝灯、SSR搭建等。推荐中国用户首选ExpressVPN翻墙，用蓝灯或者SSR作为备份。</p>\n<h1>在中国使用VPN翻墙软件需知</h1>\n<h2>墙并没有那么高</h2>\n<p>国内网名觉得墙很高，其实每年除了少数几个时段外，用VPN或SSR翻墙并不难，虽然也谈不上特别容易，毕竟买VPN或者搭建SSR都要费时间费钱。很多人觉得翻墙难，大概就是几类原因。首先就是不想花钱，整天找免费的东西，免费VPN，免费SSR节点分享，免费的东西很多，也有一些确实能用的，但几乎所有免费服务最终都是很难或不可用的。绝大多数免费的VPN或者SSR节点，公网上随便一搜就搜得到，你能看到墙也能看到，多数都很短命。其次就是懂点技术的网民的那一点偏执，觉得自己架设的东西最好，不相信第三方更专业的付费服务。国内很多人用香港、日本等地的主机来搭SSR，有不少确实是稳定地用着，但也有不少IP被封，不得不折腾换IP、换主机的。所以它们觉得翻墙很难。</p>\n<p>其实翻墙只需要准备一两个工具就行了，像我自己就常备<a href=\"https://indx.cc/exp\">ExpressVPN</a>和<a href=\"https://indx.cc/lantern\">蓝灯</a>，用了好几年了，除了少数敏感时期两个都挂掉以外，其余时间基本可以保证100%翻墙成功率，绝大多数时候我用ExpressVPN，虽然每天都会有几次断线重连，但极少碰到连不上的情况，最糟糕的情况也就是换个节点连一下，香港的如果连起来慢了，就换洛杉矶的，洛杉矶的慢了，就换日本、新加坡的等等。蓝灯用来作备份，因为价格便宜，但没有ExpressVPN强大，有了这两个软件，我从来没担心过无法翻墙的问题。剩下的，就是保持两个工具的更新，这是同时安装两个翻墙软件的好处，主要是为了当一个软件版本过期无法连接的时候，另一个还能连上让它更新。</p>\n<h2>翻墙是为了不影响学习与工作，不是去诋毁中国和中国人</h2>\n<p>你要明白世界的媒体是受西方控制的，舆论战里众多西方媒体是进攻的一方，而非西方阵营的国家只能选择防守，我们不说墙的存在对你我个人是好或不好，方便与不方便，如果说这个，当大概是不好也不方便，但也得明白防火墙存在在政治与国家安全上的‘合理性’。比如Facebook被封的原因：</p>\n<blockquote>\n<p>由于乌鲁木齐七·五骚乱部分新疆独立运动者使用Facebook为交流平台，引起中国大陆封锁Facebook至今。</p>\n</blockquote>\n<p>绝大多数西方媒体都带有浓烈的意识形态企图，它们绝对不是“公正中立”的，明白这一点的中国人会越来越多。<a href=\"https://user.guancha.cn/main/content?id=29826\">选择性报道，恶意扭曲的例子并不少</a>，甚至一度还有“中国共产党镇压狗”的奇葩新闻，西方媒体说谎作恶，无所不用其极。翻墙绝对不是为了去做西方媒体的喉舌，你只要被绕进去，就很难看到全部的事实了。翻墙是首先是为了不影响个人学习与工作，其次是为了更好地学习和工作，还当然有娱乐：）Googe，Youtube，Facebook，Twitter上都有大量有益的信息可以看。况且前面说了，对个人来说，墙的门槛实际上并没有你想的那么高，墙的存在并不能阻止你获得这些信息。</p>\n<p>不要假设“翻墙后”的必然选择是搞些猎奇反动的事情，翻墙后有很多有趣、有意义的东西可以看。有一些免费翻墙工具背后是美国国会支持的，典型代表是曾经流行的自由门，就有美国国会几百万美金的拨款，自由门绝对不是唯一一款，这种免费VPN会向用户不停推送反动信息，好在几年前被封了。</p>\n<h2>绝不要分发分享自建VPN，SSR机场，脚本等</h2>\n<p>国内有些小朋友看到搭建SSR这么容易，就去建机场，这是典型的作死，可以自行去搜机场主或者站长被请抓的新闻。个人VPN，SSR你自己用，请保持低调。不要到微信、微博这些地方去分发，除非你很想喝茶。分发分享自建VPN，SSR机场是犯法的。 看下面这些事件：</p>\n<p><strong>2019年3月，翻墙技术网站“逗比根据地”站长被起诉：</strong></p>\n<p>“逗比根据地”是一个提供翻墙技术的中文网站。2018年底，该网站创始人孙东洋（网名Toyo Sun）在国内被捕。在被关押5个多月后，孙东洋于2019年3月25日被以“提供侵入计算机系统工具罪”起诉。</p>\n<p><strong>2019年1月，重庆网民因使用VPN受到指控：</strong></p>\n<p>2019年1月，据网络流传的图片显示，重庆市荣昌区公安局对一名使用VPN的网民黄某的家属进行了传唤。</p>\n<p><strong>2019年1月，广东网民因使用VPN被罚款：</strong></p>\n<p>2019年1月，广东一位朱姓网民因为“擅自建立、使用非法定信道进行国际联网”被韶关市公安局警告并罚款1,000元人民币。文件显示：朱某从2018年8月到12月，在自己手机上多次使用翻墙软件蓝灯（Lantern Pro）。这是一次因个人使用VPN被罚的事件。</p>\n<h1>什么才是中国好用的翻墙软件</h1>\n<p>中国的翻墙软件目前就两大类：一是VPN（OpenVPN等多种协议），二是加密代理（HTTPS，SOCKS5）。</p>\n<p>VPN分免费的和付费的，绝大多数都有自己的加密和混淆算法，以绕过防火墙侦测。这个东西需要大量技术与人力的投入，所以几乎所有免费VPN和绝大多数小的付费VPN厂商都做不到长期稳定翻墙，因为它们的加密和数据混淆算法在防火墙的DPI（Deep Packet Inspection）面前不堪一击。剩下的VPN厂商都是有技术实力和预算来持续更新算法的。而且，中国国内的VPN大多数都关了，国外大多数VPN官网被墙，也无法购买。剩下的也只有那些重视中国VPN市场的大的厂商才能持续更新中国VPN镜像站了。</p>\n<p>加密代理的技术五花八门，蓝灯，SS，SSR，V2Ray，Brook，WireGuard。目前中国网民里蓝灯和SSR有较多人使用，V2Ray，Brook，WireGuard技术门槛比较高，还很小众。蓝灯作为一个免费+付费的代理翻墙服务，口碑还好。自己搭建的SSR私服非常多，国外VPS服务商那里被封禁的IP也特别多。</p>\n<p>所以现在能推荐的翻墙软件，无非国外的VPN大厂商，还有靠谱一点的SSR节点。但总的来说，付费VPN的长期翻墙能力更有保障，毕竟人家一个公司的人力与技术投入进去的。现在中国能推荐的VPN翻墙软件很少。</p>\n<h1>中国VPN翻墙软件推荐</h1>\n<h2><a href=\"https://indx.cc/exp\">ExpressVPN</a> - 最好用的中国VPN</h2>\n<p>如果只能推荐一个<a href=\"https://www.expressvpn.com/de/what-is-vpn\">VPN</a>，那应该是ExpressVPN，它是市场上价格最高的，但稳定性和速度是最好的。</p>\n<p><strong>为什么ExpressVPN是最好用的中国VPN翻墙软件？</strong></p>\n<p>世界上的VPN软件成千上万，愿意为中国用户提供镜像站的一只手数得过来，<a href=\"https://indx.cc/exp\">ExpressVPN的镜像站</a>对中国用户始终保持着可访问。</p>\n<p>客户端好用的VPN不少，但提供无需Google Play Store和苹果美国商店即可安装客户端的VPN厂商，恐怕ExpressVPN是仅有的几家之一。</p>\n<p><strong>所以，为什么推荐ExpressVPN？因为它重视中国市场。</strong></p>\n<p><img src=\"https://xvp.akamaized.net/assets/public/affiliate-assets/logo/expressvpn-white-on-red-stacked-rgb-afe268fa96e1fc10375a6bd3a3dc8b67.png\" alt=\"中国VPN翻墙软件推荐\"></p>\n<p>推荐香港、日本、新加坡、美国节点，提供国内能打开的镜像站，<a href=\"https://indx.cc/exp\">不翻墙即可购买</a>，真正全终端覆盖，电脑（Windows，MacOS，Linux），手机（安卓，iOS：iPhone，iPad），路由器，游戏主机（PS2，XBox）等，安卓手机无需Google Play也可安装，iOS设备无需访问苹果商店也可安装，同时5台设备，单独配置哪些应用走VPN哪些不走（Split Tunneling） ，30天无条件退款，<a href=\"https://indx.cc/exp\">买一年送3个月</a>，支持支付宝付款，支持P2P下载，不限流量。</p>\n<p><strong>ExpressVPN教程（需翻墙看）</strong></p>\n<ul>\n<li><a href=\"https://youtu.be/RL9Im-dj7Ow\">安卓</a></li>\n<li><a href=\"https://youtu.be/9QCSkP5of2M\">Mac</a></li>\n<li><a href=\"https://youtu.be/QawZO5LPUCw\">iOS</a></li>\n<li><a href=\"https://youtu.be/9GqvZdCj8lU\">Linux</a></li>\n</ul>\n<h3><a href=\"https://www.pandabear.pw/purchase?status=register&amp;invitationCode=JK%2BqgSOdznw9wEcHMtueCA%3D%3D\">熊猫VPN</a></h3>\n<p>VPN的后起之秀，正在促销，<strong>买一年送一年</strong>，服务器亲测可用，而且很快（可能因为用户还不多的原因）。</p>\n<p>支持Windows，Mac，iOS，Android客户端。连接VPN只需要一个开关即可。界面极其简洁，同时3台设备，这是一个让人惊喜的发现。支持智能分流。</p>\n<h3><a href=\"https://indx.cc/vyr\">VyprVPN</a></h3>\n<p>推荐台湾、韩国，香港、日本、新加坡、美国等地节点，不用翻墙国内可以购买，独家变色龙混淆协议 ，同时5台设备，30天无条件退款，支持支付宝付款，支持P2P下载，不限流量。</p>\n<p>VyprVPN是我确定中国能用的VPN软件，台湾、韩国的节点出奇地快。VyprVPN的价格低于ExpressVPN，对于觉得ExpressVPN太贵的用户，我推荐你用VyprVPN。</p>\n<p>一分钱一分货，VyprVPN的设备支持，可用节点书（对中国用户）没有ExpressVPN强大。</p>\n<h3><a href=\"https://indx.cc/nrd\">NordVPN</a></h3>\n<p>香港，日本，美国节点，同时6台设备，可能要翻墙购买，随时退款。NordVPN很便宜，而且能随时退款。</p>\n<h3><a href=\"https://indx.cc/pure\">PureVPN</a></h3>\n<p>香港，日本，美国节点，同时5个连接，需要翻墙购买，31天无条件退款。</p>\n<h1>关于免费VPN</h1>\n<p>不推荐免费VPN。</p>\n<p>但如果实在不想花钱，或者平时用的不多，可以考虑用免费VPN，目前还是有可以用的，只是要找找，免费的一般都不是很稳定。</p>\n<p>百度里基本是搜不到的，谷歌可以，只是搜到的未必能用，绝大多数用不了，也有少数能用。安卓官方市场里有很多免费VPN，可以试试，苹果官方（美国）市场也是。</p>\n<p>只可惜国内大多数手机既没有装Google Play Store，也没有苹果美国市场帐号，所以会比较麻烦。有的APK是可以从第三方市场下载的，可以试试。你也可以自己搞到苹果美国店的帐号，也不难。</p>\n<p>免费VPN最大的问题是服务本身，一是客户端广告推送往往比较疯狂，体验不好，二是免费版的限制太多，最终你还得买付费版，三是因为免费的东西用的人本来就多，流量经常不够分，实际可用性不会好。</p>\n<h1>关于破解VPN</h1>\n<p>不要相信什么破解VPN，根本不能用。因为VPN软件都分客户端和服务器端，破解了客户端又什么用的，服务端算法、服务地址等都会变，所以没什么卵用。</p>\n<p>破解版软件很容易被挂马，带病毒，别说我没提醒你。实在不想花钱的，至少可以用免费版。</p>\n<h1>关于VPN翻墙的稳定性和速度</h1>\n<p>没有100%稳定的VPN，每年特殊时间段（如六月初）的连接质量都不好，容易断线，这不是某个VPN的问题，所有的翻墙软件都会这样，一般到六月中就会完全恢复。</p>\n<p>日常使用，偶尔断线，换服务器重连即可。</p>\n<p>即使是同一个服务，在一天不同时段，或在不同地域访问，服务质量也会不同，如果你带着小飞机全国各地跑，也是一样，这是由当地网络状况决定的。</p>\n<p>网上说的什么某个VPN软件看油管一年365天一天24小时都能1080P，是不可信的。但ExpressVPN这样的，可以做到一年99%的时间内，都可以流畅观看720P的视频。</p>\n<h1>中国最快的VPN节点</h1>\n<p>香港到大陆的ping值是最低的（小于100ms），如果软件提供，应该是最优质的翻墙节点。日本（100ms至200ms之间），美国（200ms以上），新加坡（200ms以上），都是连接稳定速度较好的VPN节点。</p>\n<p>提供台湾节点和韩国节点的VPN不多，我自己的感觉，连上的时候很快，但经常连不上，不知道什么原因。</p>\n<h1>其它翻墙软件（非VPN）</h1>\n<h2>蓝灯</h2>\n<p>蓝灯不是VPN，严格地说，是加密代理。提供免费版和付费版，免费版每月好像是500M流量，付费版的价格也不贵。</p>\n<p>代理类翻墙软件的连接速度一般比传统VPN快，理论上传输速度也比VPN快，不过因为增加了加密层协议，速度优势并不明显。</p>\n<p>蓝灯在Windows，MacOS，安卓提供上提供客户端，下载安装方便，但是<strong>蓝灯不支持iOS</strong>，很遗憾。对路由器、游戏主机等设备的支持自然也没有VPN好。</p>\n<p>蓝灯相比传统VPN的另一个缺陷，是DNS泄露的概率比较大，DNS查询既你打开某个网址发出的域名解析请求，一线的VPN都提供更好的DNS保护。</p>\n<p>如果你觉得VPN太贵，不妨试试蓝灯，用这个优惠码可以便宜点：NQGP7F。</p>\n<h2>自己搭建SSR（ShadowSocksR）</h2>\n<p>SSR，又称“<strong>小飞机</strong>”，或“<strong>影梭</strong>”，是<a href=\"https://shadowsocks.org/en/index.html\">ShadowSocks</a>的后续版本，目前仍保持着更新（原项目黄了）。</p>\n<p>这种方法也是完全可行的，国内很多人用，现在最常见的SSR，也有小众用户用V2Ray，WireGuard等技术，总的来说SSR够用。</p>\n<p>用得最多的VPS是<a href=\"https://indx.cc/vtr\">Vultr</a>和<a href=\"https://indx.cc/bwg\">搬瓦工</a>，网上不少人反应IP被封，但也有很多人自己搭建的SSR稳定用很久的，所以这里有运气成分。</p>\n<p>自己搭建SSR并不比买VPN便宜，即使便宜其实也很有限，主要还是VPS厂商经常送新注册用户试用金，所以感觉上一开始不用花钱，大家觉得便宜，最便宜的VPS如Vultr的2.5美金每月的，也和一些VPN的价格差不多，VPS普遍的低配机价格是5美金或以上的。</p>\n<p>要有IP被封的心里准备，好在现在的VPS换IP都不麻烦，大不了做个镜像重新开一台机会拿到新IP。</p>\n<h1>比较一下几类翻墙软件</h1>\n<h2>VPN vs. 蓝灯</h2>\n<p>蓝灯更便宜，稳定性速度都不错。VPN稍贵，稳定性速度相当。蓝灯最大的缺点是没有iOS版，VPN的客户端支持很全面，电脑、安卓设备上，VPN和安卓都好用。。VPN的隐私保护能力更强，蓝灯的稍弱。蓝灯自带广告过滤功能，用处不算太大，但聊胜于无，有的VPN提供广告自动过滤，绝大部分不提供。蓝灯不能手选连接节点，只能自动连接，既方便也不方便，如果要翻墙看Netflix追剧的，建议VPN吧。</p>\n<h2>VPN vs. SSR</h2>\n<p>SSR的最大优势是可选择的VPS不少，挪窝比较容易，缺点是对技术小白不友好，安装配置不算难，但也足以难道大多数人。前面说过，SSR在价格上并不必VPN便宜多少。传统VPN翻墙的最大优势是稳定性，像ExpressVPN这样的商业服务，客户端服务器端都不停在迭代，穿墙能力自然更有保障。</p>\n<h2>蓝灯 vs. SSR</h2>\n<p>这两个其实非常相似，本子都是代理，蓝灯也很可能走的SOCKS5协议，只不过加密和混淆方法不同而已。蓝灯是个商业软件，可用性比众多自己搭建的SSR要好很多，但SSR的配置灵活性显然优于蓝灯，选谁就看你的偏好了。</p>\n<h1>总结一下</h1>\n<ul>\n<li>电脑翻墙：VPN，蓝灯，SSR都是可行的方案。对小白来说，VPN和蓝灯的客户端省去配置的麻烦，花钱省时间。如果懂技术，SSR也不错。</li>\n<li>安卓翻墙：VPN和蓝灯都不错，看个人，SSR也行，不过个人觉得SSR手机客户端没有桌面客户端好用。</li>\n<li>iOS翻墙：VPN是最好的方案，SSR也行，但可能买付费的客户端会比较好，免费的都不是很好用。</li>\n<li>路由器翻墙：VPN软件提供的可自动安装工具应该是最方便的选择。</li>\n<li>智能电视：取决于电视操作系统。</li>\n<li>游戏主机：VPN是最好的选择。</li>\n</ul>\n<h1>附：VPN术语解释</h1>\n<h2>隐藏IP地址</h2>\n<p>连上VPN后，所有流量都走VPN软件提供的线路，相当于在本机与VPN远程服务器之间建立起一条秘密通道，入口是本机端口，出口是服务器某个端口，对被访问的网站等服务来说，直接访问者是远程服务器，从而达到隐藏本机IP地址的目的。</p>\n<p>隐藏IP地址即是保护隐私的需要，在需要访问有IP限制的服务时（如Netflix只允许部分国家的IP访问）也非常有用。</p>\n<h2><a href=\"https://en.wikipedia.org/wiki/DNS_leak\">DNS泄漏保护</a></h2>\n<p>上面说了VPN会在本机和远程服务器间开辟隧道，让流量同行，通常指的流量是数据流量，比如下载网页，DNS泄露保护，是将本机对网站域名的访问请求（转化为IP）也走VPN通道的保护机制，它最大限度地保护用户隐私，否则网络中间商就可以侦测到你的机器都访问了哪些域名，有了DNS泄露保护，网络中间商就无法嗅探到你的网站访问记录了。</p>\n<h2>混淆协议</h2>\n<p>单纯的VPN协议如OpenVPN虽然也有加密算法，但在GFW防火墙面前也不堪一击。所以好的VPN软件都会单独开发混淆协议。混淆的作用就是把VPN流量尽可能搞得不像VPN加密流量，骗过墙的侦测算法，更有效地帮助用户翻墙。</p>\n<p>ExpressVPN，VyprVPN等软件都开发了商用混淆协议，这是这类软件比普通VPN更稳定的原因。</p>\n<h2>Split Tunneling</h2>\n<p>当你连上VPN软件后，默认所有流量都走VPN连接，这会导致访问中国国内网站（如知乎、百度、微博、优酷等）变慢。Split Tunneling允许你指定那些应用程序不走VPN线路，如在<a href=\"https://indx.cc/exp\">ExpressVPN</a>内，你可以配置Firefox浏览器不走VPN，Chrome浏览器走VPN，这样访问国内站点时用Firefox，访问国外站点时用Chrome，国内外网站访问速度都能达到最优。</p>\n<p>链接：</p>\n<ul>\n<li><a href=\"https://cnodejs.org/topic/53b93bab1b009b31532ef934\">有靠谱VPN吗</a></li>\n<li><a href=\"https://www.wallmama.com/best-vpn-china-2019/\">2019年便宜好用的翻墙VPN推荐</a> （已被墙）</li>\n<li><a href=\"https://www.49gm.org/ssr%E8%8A%82%E7%82%B9%E5%88%86%E4%BA%AB%E8%AE%A2%E9%98%85-ssr%E8%B4%A6%E5%8F%B7%E8%B4%AD%E4%B9%B0-ssr%E6%90%AD%E5%BB%BA/\">SSR（ShadowSocksR，影梭）节点分享订阅，SSR客户端下载安装，SSR账号购买与搭建\n</a></li>\n</ul>\n</div>",
	"title": "中国VPN翻墙软件推荐，最好用的付费VPN，SSR节点分享",
	"last_reply_at": "2019-08-22T08:40:08.787Z",
	"good": false,
	"top": false,
	"reply_count": 29,
	"visit_count": 50243,
	"create_at": "2018-05-31T15:55:49.256Z",
	"author": {
		"loginname": "wallmama",
		"avatar_url": "https://avatars3.githubusercontent.com/u/39631585?v=4&s=120"
	}
}, {
	"id": "5ce6a9d54036f24194cf5f1e",
	"author_id": "5bc6779d37a6965f5905229a",
	"tab": "ask",
	"content": "<div class=\"markdown-text\"><p>請問node.js有像java 一樣的流程引擎嗎？例如jBPM、Activiti，謝謝前輩們~</p>\n</div>",
	"title": "請問node.js有像java 一樣的流程引擎嗎？例如jBPM、Activiti，謝謝前輩們~",
	"last_reply_at": "2019-08-22T05:30:33.476Z",
	"good": false,
	"top": false,
	"reply_count": 15,
	"visit_count": 2001,
	"create_at": "2019-05-23T14:10:29.327Z",
	"author": {
		"loginname": "Solomonqoo",
		"avatar_url": "https://avatars3.githubusercontent.com/u/44214486?v=4&s=120"
	}
}, {
	"id": "5d5968a1697873456c6be4d6",
	"author_id": "57d216e13d3520a5387c2b53",
	"tab": "ask",
	"content": "<div class=\"markdown-text\"><p>RT!!!</p>\n</div>",
	"title": "大家好 ，请问有什么node开源比较好的影视项目吗？",
	"last_reply_at": "2019-08-22T05:11:21.281Z",
	"good": false,
	"top": false,
	"reply_count": 4,
	"visit_count": 558,
	"create_at": "2019-08-18T15:02:57.792Z",
	"author": {
		"loginname": "a69694510",
		"avatar_url": "https://avatars1.githubusercontent.com/u/20507053?v=4&s=120"
	}
}, {
	"id": "5d2bd8ebfa8ef0094e064cca",
	"author_id": "4f4c779a940ce2e60b1e3b3f",
	"tab": "share",
	"content": "<div class=\"markdown-text\"><p>用 MacOS 做开发已经六七年了，真的很爽。体验上比 Linux 稳定，UI更完善，还兼容强大的 Terminal。比 Windows 颜值高很多，与 nix 的兼容互通性很强（当然 Linux 有自由而丰富的社区资源，Windows 有完备而坚实的应用生态）。虽然不同系统都各有所长，但就开发体验而言 MacOS 略胜一筹（毕竟能自如地进行移动端和前后端开发）。</p>\n<p>一直以来，MacOS 的 Finder 和终端直接的切换让我很手残，没有便捷的路径复制，一直cdcdcd。。。最后，我只能打开终端，然后cd拖过去的文件夹 -_-||| 而且有时候，一个项目会涉及到文档、设计稿、资源、代码等多个目录，每次都重复打开多个 Finder 窗口来回切换，真的很晕。。。</p>\n<p>于是就在想，能不能开发一款带有Chrome式地址栏（直接输入地址、拷贝地址。。想想就很爽），并且能把窗口切分成 N 个视图区域，最好还能一直保持工作区状态的小工具？想的差不多了就开干，从设计到coding完成，大概花了两周左右的时间，QSpace 第一个版本终于上线了！</p>\n<p>第一个版本完成了以下功能：</p>\n<p>【多视图工作区】</p>\n<ul>\n<li>支持 12 种视图布局，一键灵活切换。</li>\n<li>支持创建多个工作区，并可快速切换。</li>\n<li>所有工作区状态自动保存，再次打开即可恢复！</li>\n</ul>\n<p>【文件管理增强】</p>\n<ul>\n<li>浏览器式地址栏：支持前进、后退、前往上级、拷贝或直接输入路径等操作。</li>\n<li>终端快捷键：一键在指定终端打开已选择目录（支持 Terminal、iTerm、Hyper）</li>\n<li>编辑器快捷键：一键在指定编辑器打开已选择的文件或目录（支持 VSCode、Atom、Sublime）</li>\n<li>支持在任意位置创建空文件、文件夹。</li>\n<li>支持工作区视图之间拷贝、粘贴、拖拽等操作。</li>\n<li>支持工作区视图与其他应用之间拷贝、粘贴、拖拽等操作。</li>\n<li>按回车可直接打开文件或进入目录。</li>\n</ul>\n<p>欢迎有类似困扰的开发者加入体验！\n<a href=\"https://apps.apple.com/cn/app/id1469774098\">https://apps.apple.com/cn/app/id1469774098</a></p>\n<p><img src=\"//static.cnodejs.org/FgMAoG9Mq4zvBU4XlxzVJOQVgWlK\" alt=\"屏幕快照 2019-07-15 上午9.28.58.jpg\">\n<img src=\"//static.cnodejs.org/FlFsr4bv1lNcdL9GvrOxYQizArCB\" alt=\"屏幕快照 2019-07-15 上午9.29.18.jpg\"></p>\n</div>",
	"title": "一款 MacOS 多视图 \"Finder\" 效率工具，尤其适合前后端开发者。",
	"last_reply_at": "2019-08-22T03:29:47.151Z",
	"good": false,
	"top": false,
	"reply_count": 3,
	"visit_count": 966,
	"create_at": "2019-07-15T01:37:47.462Z",
	"author": {
		"loginname": "vendar",
		"avatar_url": "//gravatar.com/avatar/246abe2445d43c1497ff0481c0ab524c?size=48"
	}
}, {
	"id": "5ba523da37a6965f59051bbd",
	"author_id": "53210f5661ed405564023e05",
	"tab": "ask",
	"content": "<div class=\"markdown-text\"><p>或许是 sequelize 基础知识不牢靠，并不关 egg 问题，我先描述一下：</p>\n<p>有两个表： <code>brand</code> 和 <code>ris</code>, 都是多对多关系，另外还有一个关系表 <code>ris_to_brand</code>。</p>\n<p>brand 表关联写法如下：</p>\n<pre class=\"prettyprint\"><code>Brands.associate = function() {\n    app.model.Brands.belongsToMany(app.model.Ris, { as: &#x27;bri&#x27;, through: &#x27;ris_to_brand&#x27;, foreignKey: &#x27;brand_id&#x27; });\n  };\n</code></pre><p>ris 表关联写法如下：</p>\n<pre class=\"prettyprint\"><code>Ris.associate = function() {\n    app.model.Ris.belongsToMany(app.model.Brands, { as: &#x27;rib&#x27;, through: &#x27;ris_to_brand&#x27;, foreignKey: &#x27;ris_id&#x27; });\n  };\n</code></pre><p>ris_to_brand 表结构分别是 <code>id, ris_id, brand_id</code>。</p>\n<p>我运行的时候报如下错误：\n<img src=\"//static.cnodejs.org/FkiiD_M4XyRNghUSAyh_rswCKE2d\" alt=\"image.png\"></p>\n<p>说我 <code>ris_to_brands</code> 表不存在，按我的理解，我指定的是 <code>through: ris_to_brand</code> ，怎么会去寻找 <code>ris_to_brands</code> 这个名称的表呢？\n不明白。</p>\n</div>",
	"title": "egg-sequelize 关联查询请教",
	"last_reply_at": "2019-08-22T03:11:39.279Z",
	"good": false,
	"top": false,
	"reply_count": 6,
	"visit_count": 1546,
	"create_at": "2018-09-21T17:01:14.455Z",
	"author": {
		"loginname": "littledu",
		"avatar_url": "https://avatars2.githubusercontent.com/u/1784673?v=4&s=120"
	}
}, {
	"id": "5d5dfa78e79eaa6628beb62f",
	"author_id": "59b7a76ee483de126798458e",
	"tab": "share",
	"content": "<div class=\"markdown-text\"><h1>斯坦福编程范式第二课笔记（数据类型在内存中的表示）</h1>\n<p>内存的最小单位是字节，一个字节等于8位（bit），每一位要么是0要么是1，也就是用二进制来表示。</p>\n<p>一个字节在内存中的表示为：</p>\n<p><img src=\"https://image.coder.cat/bit.png\" alt></p>\n<h2>无符号整数的表示</h2>\n<p>无符号二进制转成十进制公式：</p>\n<p><img src=\"https://image.coder.cat/dd2fc7ee8cc062f42a633e67c9cd7fe6.png\" alt></p>\n<ul>\n<li><code>w</code>：二进制位的长度。</li>\n<li><code>i</code>：二进制位从右往左开始的下标，从0开始计数。</li>\n<li><code>w-1</code>：由于i是从0开始计数，所以最后一个下标就是w-1。</li>\n<li><code>x(i)</code>：第<code>i</code>位的值，要么是0要么是1。</li>\n<li><code>2^i</code>：2的第<code>i</code>次幂。</li>\n</ul>\n<p>例如：\n无符号二进制数<code>10010</code> 按照公式展开就是：</p>\n<p><img src=\"https://image.coder.cat/ce0c541a239b16c32885adb9f36cc850.png\" alt></p>\n<p>如果把这个数用1个字节在计算机中存储，内存中就表示为：</p>\n<p><img src=\"https://image.coder.cat/bit%202.png\" alt></p>\n<p>不足8位，左边补0。</p>\n<p>1个字节的无符号正式能表示<code>2^8 = 256</code>个不同的数。能表示最大的数是8个二进位全是1的数等于255，也就是求一个<code>公比为2</code>，<code>首项是1</code>的<code>等比数列</code>前8项和。二进制位求和公式为<code>(2^n) - 1</code>。总结下来一个n位的二进制数能表示最大的数是<code>(2^n) - 1</code>，能够表示<code>2^n</code>个不同的数，之所以是2^n个不同的数，是因为可以表示<code>0~(2^n) - 1</code>，从0开始的所以还需要<code>+1</code>个长度。</p>\n<h2>Char在内存中的表示</h2>\n<blockquote>\n<p>Char类型是用来存储单个字符，在内存中占用1个字节的大小，它使用8个bit来表示256个字符。\nChar类型实际存储的是字符的<code>ASCII</code>码，由于<code>ASCII</code>码是整数。所以Char最终在内存中是一个8bit的整型。</p>\n</blockquote>\n<p>比如字符<code>A</code>的<code>ASCII</code>码是65，65 = 2^0 + 2^6，所以在内存中的表示为：\n<img src=\"https://image.coder.cat/bit%203.png\" alt></p>\n<pre class=\"prettyprint language-c\"><code>char ch = &#x27;A&#x27;;\nprintf(&quot;%d&quot;, ch); &#x2F;&#x2F; output is 65\n</code></pre><h2>Short在内存中的表示</h2>\n<blockquote>\n<p>Short 表示的是短整型，一般占用2个字节的内存大小。</p>\n</blockquote>\n<p>它的取值范围是<code>(-2)^15~(2^15)-1</code>包含0。最大值这里是<code>(2^15)-1</code>，是因为short有符号位，需要用最高位（用从左到右第一位）来表示符号，0表示正数，1表示负数。 最大值的二进制表示为<code>0111111111111111</code>(16个二进制位)，十进制就是<code>(2^15)-1</code>。 之所以是<code>(2^15)-1</code>，也是之前说的求和公式(<code>(2^n)-1</code>。</p>\n<h2>实现加减法</h2>\n<blockquote>\n<p>二进制加减法和十进制一样，把对应<code>位</code>相加，大于1就向前进位。例如<code>0111 + 1 = 1000</code></p>\n</blockquote>\n<p>如果想要把7和-7相加使结果等于0。按照在计算机中使用二进制的最高位来当做符号位的，0表示正数，1表示负数。那么7表示为<code>0000111</code>，-7就表示为<code>1000111</code> 。0000111 + 1000111 按照二进制先前的加法法则得出来是<code>1001110</code>，结果不是我们想要的0。</p>\n<blockquote>\n<p>怎么才能让2个二进制数相加得到0呢？</p>\n</blockquote>\n<p>想要得到0，就需要利用进位，比如在<code>11111111</code>（8个1）的基础上加1就可以得到<code>100000000</code>(一共9位，左边第一位是1，后面8个0) ，舍掉最左边的那个1就得到了8个0最终结果就等于0。把原码按位取反然后与原码相加就可以得到全1的二进制数。比如<code>0000111</code>按位取反就是<code>1111000</code>，他们俩相加得到<code>11111111</code>。 再把它加1就得到最后的结果0。整个过程需要3步，我们把最后两步合并成一个步骤，也就是把按位取反和加1合并到一起，其实就是把原码的反码加1。如<code>1111000</code>加1得到<code>1111001</code>。最后这两步合在一起叫做取原码的补码。最后得到的<code>1111001</code>就叫做<code>0000111</code>的补码。</p>\n<ul>\n<li>正整数的补码是其本身。</li>\n<li>负整数的补码是把它对应的正整数二进制码按位取反，也就做原码的反码然后再加1。</li>\n</ul>\n<p>比如正整数<code>7</code>的二进制码是<code>0000111</code>，它的补码还是它本身。再比如<code>-7</code>对应的正整数二进制码是<code>0000111</code>，它的反码就是<code>1111000</code>（把原码按位取反）。然后再<code>加1</code>就得到<code>1111001</code>。<code>1111001</code>就是<code>-7</code>的补码。我们再次把<code>1111001</code>和<code>0000111</code>按照二进制加法法则相加刚好得到0。这里需要注意的是，这里左边会产生一个溢出位，这个溢出位是去掉不要的，得到结果就是0。</p>\n<p>-1的补码全是1，因为它加上1之后就变成了0。</p>\n<blockquote>\n<p>计算机系统都是用补码来表示二进制码，这样的好处之一就是可以让加减法运算统一处理。</p>\n</blockquote>\n<h2>位模式拷贝</h2>\n<blockquote>\n<p>当把<code>char</code>类型的变量赋值给<code>short</code>类型的变量时，会把<code>char</code>的8个bit放在<code>short</code>的低八位（从右往左第一个字节）上。</p>\n</blockquote>\n<p>例如：</p>\n<pre class=\"prettyprint language-c\"><code>char ch = &#x27;A&#x27;; &#x2F;&#x2F; &#x27;A&#x27; ASCII：65 内存表示为 01000001\nshort s = ch; &#x2F;&#x2F; 内存表示为 00000000 | 01000001\n</code></pre><p>一个特殊的情况就是当把一个<code>short</code>的<code>-1</code>赋值给一个<code>int</code>变量的时候，并不会得到<code>00000000 | 00000000 | 11111111 | 11111111</code>，因为如果这样的话表示的值就不是<code>-1</code>了。所以正确的做法就是把<code>所有的1</code>全部拷贝给<code>int</code>。\n例如：</p>\n<pre class=\"prettyprint language-c\"><code>short s = -1; &#x2F;&#x2F; 内存表示为 11111111 | 11111111\nint i = s; &#x2F;&#x2F; 内存表示为 11111111 | 11111111 | 11111111 | 11111111\n</code></pre><p>相反如果把<code>short</code>类型的变量赋值给<code>char</code>类型的变量时，会把<code>short</code>的低八位（从右往左第一个字节）放在<code>char</code>仅有的一个字节上。会把多的字节自动剔除。\n例如：</p>\n<pre class=\"prettyprint language-c\"><code>short s = 65; &#x2F;&#x2F; 内存表示为 00000001 | 01000001\nchar ch = s; &#x2F;&#x2F; 内存表示为 01000001\n</code></pre><h2>浮点数的表示</h2>\n<p>我们已经知道无符号二进制转成十进制公式为：</p>\n<p><img src=\"https://image.coder.cat/dd2fc7ee8cc062f42a633e67c9cd7fe6.png\" alt></p>\n<p>这里的<code>i</code>是从0开始的也就是从右边的第一位是<code>2^0</code>，如果我们从一个负整数开始的话，就会存在负整数次幂，那么也就会出现小数部分了。\n例如有一个16位的二进制数<code>000000011 | 11000000</code>  用它的前八位来表示整数部分，后八位来表示小数部分，就也可以这样表示<code>000000011.11000000</code>。这样后八位也就不再是整数次幂了，而是从左到右每一位分别是<code>2^(-1)~2^(-8)</code>。这个数就可以表示成：</p>\n<p><img src=\"https://image.coder.cat/8c7bdb11f670c587afe6a694ed948c90.png\" alt></p>\n<p>这是其中一种浮点数表示方法，这种方法表示的浮点数会出现精度不够，表示的数值区间比较小，所以计算机实际并没有用该方法来表示浮点数。</p>\n<p>下面这种方法就是计算机内部真实表示浮点数的方法。</p>\n<p>我们先来看下十进制的科学计数法，用科学计数法表示123.45的话就是<code>1.2345 * 10^2</code>。其中1.2345 为<code>尾数</code>，10为<code>基数</code>，2为<code>指数</code>。计算机在表示浮点数的时候，也借用了十进制的科学计数法的思想，只不过基数为<code>2</code>了。</p>\n<p>例如<code>1000.01</code> 可以表示成<code>1.00001 * 2^3</code>，几次幂，小数点就向右移动几位。</p>\n<p>用<code>32位</code>的<code>float</code>来举例，首位是符号位<code>S</code>，紧跟后面<code>8位</code>是指数位<code>E</code>，最后<code>23位</code>称为尾数位<code>M</code>。</p>\n<p>计算公式：</p>\n<p><img src=\"https://image.coder.cat/cb4484727e77374e1bec9da86a091c4e.png\" alt></p>\n<ul>\n<li>S：符号位</li>\n</ul>\n<blockquote>\n<p>S为0时刚好是正数，为1时是负数。</p>\n</blockquote>\n<ul>\n<li>M：尾数部分</li>\n</ul>\n<blockquote>\n<p>它的取值范围是<code>1≤M＜2</code>，取值方式是从左到右每一位分别表示的是<code>2^-1~2^-23</code>，值就是然后对各个位的表示值求和，这里跟先前浮点数表示的办法一致，都是从负整数次幂开始。由于尾数的整数部分始终都是<code>1</code>，所以这个<code>1</code>可以被省略，这样就可以多出一位来提升精度。</p>\n</blockquote>\n<ul>\n<li>E：指数部分</li>\n</ul>\n<blockquote>\n<p>减去127是因为偏移量是127。</p>\n</blockquote>\n<p>例如<code>0 | 10000010 | 11110000000000000000000</code>的每一部分别是：</p>\n<ul>\n<li>S：<code>0</code></li>\n</ul>\n<blockquote>\n<p>表示整数。</p>\n</blockquote>\n<ul>\n<li>M：<code>11110000000000000000000</code></li>\n</ul>\n<blockquote>\n<p>这里需要再加1，因为为了提升小数精度省略了1，所以要加回来。所以完整的尾数部分应该是<code>1.1111</code>（省略了后面的0）。 2^0 + 2^-1 + 2^-2 + 2^-3 + 2^-4  = 1.9375</p>\n</blockquote>\n<ul>\n<li>E：<code>10000010</code></li>\n</ul>\n<blockquote>\n<p>2^7 + 2^1 = 130</p>\n</blockquote>\n<p>分别带入公式得：</p>\n<p>二进制形式：</p>\n<p><img src=\"https://image.coder.cat/7174f02edf01c94699f4b0a1a5f0dede.png\" alt></p>\n<p>十进制形式：</p>\n<p><img src=\"https://image.coder.cat/c49854e22c96541aad7f80c6d0644331.png\" alt></p>\n<p>详细过程：\n<code>1 * 1.1111 * 2^(130-127)</code> =&gt; <code>1 * 1.1111 * 2^3</code> =&gt; <code>1 * 1111.1</code>（几次幂，小数点就向右移动几位） =&gt; <code>1 * (2^3 + 2^2 + 2^1 + 2^0 + 2^-1)</code> =&gt; <code>1 * (8 + 4 + 2 + 1 + 0.5)</code> =&gt; 15.5</p>\n<h2>浮点数与整数相互赋值</h2>\n<p>当我们在把浮点数与整数相互赋值的时候，并不会直接拷贝bit位，而是重新计算出在新的类型中的位模式。\n例如：</p>\n<pre class=\"prettyprint language-c\"><code>int i = 5; &#x2F;&#x2F; 内存表示 00000000 | 00000000 | 00000000 | 00000101\n&#x2F;&#x2F; 重新计算5在float中的表示方式\nfloat f = i; &#x2F;&#x2F; 内存表示 0 | 00000000 | 00000000000000000000101\nprintf(&quot;%f&quot;, f) &#x2F;&#x2F; output is 5.0\n</code></pre><p>来一点更刺激的！！！</p>\n<pre class=\"prettyprint language-c\"><code>&#x2F;&#x2F; 2^30\nint i = 1073741824; &#x2F;&#x2F; 内存表示 01000000 | 00000000 | 00000000 | 00000000\n&#x2F;&#x2F; 这里就不会重新计算在float中的表示方式了，而是直接把bit位拷贝过去。用float的解析方式去解析int的那块内存。\nfloat f = *(float *)&amp;i; &#x2F;&#x2F; 内存表示 0 | 10000000 |00000000000000000000000\n\n&#x2F;&#x2F; 1 * 2^(128-127) * 1 = 2\nprintf(&quot;%f&quot;, f) &#x2F;&#x2F; output is 2.0\n</code></pre><p>这里就不会重新计算<code>1073741824</code>在float中的表示方式了，而是直接把<code>int</code>的<code>bit位拷贝过去</code>。用float的解析方式去<code>解析int的那块内存</code>。</p>\n</div>",
	"title": "斯坦福编程范式第二课笔记（数据类型在内存中的表示）",
	"last_reply_at": "2019-08-22T02:14:16.720Z",
	"good": false,
	"top": false,
	"reply_count": 0,
	"visit_count": 487,
	"create_at": "2019-08-22T02:14:16.720Z",
	"author": {
		"loginname": "acodercat",
		"avatar_url": "https://avatars3.githubusercontent.com/u/16076835?v=4&s=120"
	}
}, {
	"id": "5d5c0fc5e79eaa6628beb132",
	"author_id": "57a878fd4653749872ec6ecf",
	"tab": "share",
	"content": "<div class=\"markdown-text\"><p>一款用游戏框架开发的web框架meiru。借鉴了cnode社\n区，开发出skynetlua社区，<a href=\"https://www.skynetlua.com\">https://www.skynetlua.com</a>\nmeiru框架使用lua的协程，完全不使用任何回调函数。使用skynet框架，在业务层实现多核处理</p>\n</div>",
	"title": "一款新的web框架meiru，欢迎支持",
	"last_reply_at": "2019-08-22T02:05:04.078Z",
	"good": false,
	"top": false,
	"reply_count": 18,
	"visit_count": 864,
	"create_at": "2019-08-20T15:20:37.812Z",
	"author": {
		"loginname": "linyouhappy",
		"avatar_url": "https://avatars0.githubusercontent.com/u/1627891?v=4&s=120"
	}
}, {
	"id": "5d14cb08cdb1f967c157669c",
	"author_id": "596dc452db0b6aec18a2862f",
	"tab": "share",
	"content": "<div class=\"markdown-text\"><p><img src=\"http://images.boblog.com/BOBLOG-03.png?imageView2/1/w/400/h/200\" alt=\"img\"></p>\n<h2>这是个什么的项目？</h2>\n<p>使用 Node.js + Koa2 + MySQL + Vue.js 实战开发一套完整个人博客项目网站。</p>\n<ul>\n<li>博客线上地址：<a href=\"http://www.boblog.com\">www.boblog.com</a></li>\n<li>Github地址：<a href=\"https://github.com/liangfengbo/nodejs-koa-blog\">https://github.com/liangfengbo/nodejs-koa-blog</a></li>\n</ul>\n<h2>解决了什么问题？</h2>\n<ul>\n<li>服务端：使用 Node.js 的 Koa2 框架二次开发 Restful API。</li>\n<li>前端：Vue.js 打造了前端网站和后台管理系统。</li>\n</ul>\n<h2>项目包含什么功能？</h2>\n<p><a href=\"https://www.npmjs.com/package/koa\"><img src=\"https://img.shields.io/badge/koa-%5E2.7.0-brightgreen.svg\" alt=\"koa\"> </a> <a href=\"https://www.npmjs.com/package/koa-router\"><img src=\"https://img.shields.io/badge/koa--router-%5E7.4.0-brightgreen.svg\" alt=\"koa-router\"></a> <a href=\"https://www.npmjs.com/package/sequelize\"><img src=\"https://img.shields.io/badge/sequelize-%5E5.6.1-brightgreen.svg\" alt=\"sequelize\"></a> <a href=\"https://www.npmjs.com/package/mysql2\"><img src=\"https://img.shields.io/badge/mysql2-%5E1.6.5-brightgreen.svg\" alt=\"mysql2\"></a></p>\n<ul>\n<li>Koa2服务端\n<ul>\n<li>管理员与权限控制</li>\n<li>文章</li>\n<li>文章分类</li>\n<li>评论文章</li>\n</ul>\n</li>\n<li>前端博客网站 Vue.js</li>\n<li>后台管理系统 Vue.js</li>\n</ul>\n<h2>项目的特点</h2>\n<ul>\n<li>Koa 与 Koa 二次开发API</li>\n<li>多 koa-router 拆分路由</li>\n<li>require-directory 自动路由加载</li>\n<li>异步编程 - async/await</li>\n<li>异步异常链与全局异常处理</li>\n<li>Sequelize ORM 管理 MySQL</li>\n<li>JWT 权限控制中间件</li>\n<li>参数验证器 Validator</li>\n<li>nodemon 修改文件自动重启</li>\n<li>前后端分离</li>\n<li>使用 Vue.js 搭建前端网站和后台管理系统</li>\n</ul>\n<h2>如何使用和学习？</h2>\n<h3>数据库</h3>\n<p>启动项目前一定要在创建好 <code>boblog</code> 数据库。</p>\n<pre class=\"prettyprint\"><code># 登录数据库\n$ mysql -uroot -p密码\n\n# 创建 wxapp 数据库\n$ CREATE DATABASE IF NOT EXISTS boblog DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;\n</code></pre><h3>克隆项目</h3>\n<p>首先使克隆项目，然后进入项目根目录使用命令安装包，最后命令启动项目，代码会根据模型自动创建数据库表的。</p>\n<p>根目录都是 Node.js + Koa2 API开发源代码，根目录下的 web 文件夹下都是前端网站项目源代码，根目录下的 admin 文件夹下都是后台管理系统的源代码。</p>\n<pre class=\"prettyprint\"><code># 克隆项目代码\n$ git clone https:&#x2F;&#x2F;github.com&#x2F;liangfengbo&#x2F;nodejs-koa-blog.git\n\n# 进入koa项目根目录\n$ cd nodejs-koa-blog\n\n# 安装包\n$ npm install\n\n# 运行服务\n$ npm run dev\n\n# 打开浏览器输入回车：http:&#x2F;&#x2F;localhost:3000\n\n&#x2F;&#x2F; 前端项目使用\n1. 在根目录下进入web项目：cd web，\n2. 安装包，执行: npm install 命令，\n3. 启动服务: npm run dev; 浏览器打开：http:&#x2F;&#x2F;localhost:8080&#x2F; 即可以访问。\n\n&#x2F;&#x2F; 后台管理系统使用\n1. 在根目录下进入admin项目：cd admin，\n2. 安装包，执行: npm install 命令，\n3. 启动服务: npm run dev; 浏览器打开：http:&#x2F;&#x2F;localhost:8083&#x2F; 即可以访问。\n</code></pre><h3>接口说明（重要）</h3>\n<p>项目的所有接口文档都这里，可以逐个文档看。</p>\n<ul>\n<li><a href=\"https://github.com/liangfengbo/nodejs-koa-blog/blob/master/doc/admin.md\">管理员接口文档说明</a></li>\n<li><a href=\"https://github.com/liangfengbo/nodejs-koa-blog/blob/master/doc/article.md\">文章接口文档说明</a></li>\n<li><a href=\"https://github.com/liangfengbo/nodejs-koa-blog/blob/master/doc/category.md\">分类接口文档说明</a></li>\n<li><a href=\"https://github.com/liangfengbo/nodejs-koa-blog/blob/master/doc/comments.md\">评论接口文档说明</a></li>\n</ul>\n<h2>License</h2>\n<p>项目已实现管理员、权限管理、文章、分类、评论等接口，前端模板网站和后台管理系统。自己可以根据项目代码学习，可以到 postman 软件中测试API或学习。</p>\n<p>喜欢或对你有帮助的话，请你点一个星星 <a href=\"https://github.com/liangfengbo/nodejs-koa-blog\">star</a> 鼓励我，或者您有更好的建议和意见，请提出来告知我，可以留言 <a href=\"https://github.com/liangfengbo/nodejs-koa-blog/issues/new\">Issues</a>。希望能够帮助到你学习！Thanks！</p>\n<p><a href=\"https://github.com/liangfengbo/nodejs-koa-blog/blob/master/LICENSE\">MIT</a>, by 梁凤波</p>\n<hr>\n</div>",
	"title": "分享Node.js + Koa2 + MySQL + Vue.js 实战开发一套完整个人博客项目网站",
	"last_reply_at": "2019-08-22T01:15:03.074Z",
	"good": false,
	"top": false,
	"reply_count": 12,
	"visit_count": 1357,
	"create_at": "2019-06-27T13:56:24.884Z",
	"author": {
		"loginname": "liangfengbo",
		"avatar_url": "https://avatars3.githubusercontent.com/u/26264225?v=4&s=120"
	}
}, {
	"id": "5d54b29a697873456c6bd697",
	"author_id": "5aebafbcadea947348e76068",
	"tab": "ask",
	"content": "<div class=\"markdown-text\"><p>请问一下大家有好的code review机制么？\n平常团队review的时候总是会出现偏差，比如突然讲到了业务细节，感觉效率好低，求大佬们分享和建议，\n评论也会给其他需要review的coder建议🤗</p>\n</div>",
	"title": "code review机制",
	"last_reply_at": "2019-08-21T14:09:35.187Z",
	"good": false,
	"top": false,
	"reply_count": 22,
	"visit_count": 1101,
	"create_at": "2019-08-15T01:17:14.594Z",
	"author": {
		"loginname": "Rabbitzzc",
		"avatar_url": "https://avatars0.githubusercontent.com/u/26913511?v=4&s=120"
	}
}, {
	"id": "5d2e803f51637b492bb0f5d0",
	"author_id": "5c05dd981c62d8334935059c",
	"tab": "share",
	"content": "<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/Fj9lYwgwM5z9Z-s36JRZIiWFUExp\" alt=\"image.png\">\n简洁、大方、收录全。希望大家喜欢~\n<a href=\"https://geekdocs.cn/\">程序员导航 - 国内最专业的程序员网址导航！</a></p>\n</div>",
	"title": "给大家分享一个程序员网址导航站~",
	"last_reply_at": "2019-08-21T13:31:04.600Z",
	"good": false,
	"top": false,
	"reply_count": 11,
	"visit_count": 2120,
	"create_at": "2019-07-17T01:56:15.006Z",
	"author": {
		"loginname": "WuYinMan",
		"avatar_url": "https://avatars2.githubusercontent.com/u/28140607?v=4&s=120"
	}
}, {
	"id": "5a22bfbc8eab6ee92a694618",
	"author_id": "57b08034a4f7e29c763413ef",
	"tab": "share",
	"content": "<div class=\"markdown-text\"><p>#Stickpackage</p>\n<h2>StickPackage，NodeJs中TCP粘包、分包解决方案！</h2>\n<p><a href=\"https://github.com/lvgithub/stickPackage.git\">持续更新，源码地址，喜欢的话请点star，想订阅点watch</a></p>\n<hr>\n<h2>目录</h2>\n<ul>\n<li>安装</li>\n<li>配置介绍</li>\n<li>API</li>\n<li>更新记录</li>\n<li>使用方法</li>\n<li>案例演示</li>\n</ul>\n<hr>\n<h2>安装</h2>\n<pre class=\"prettyprint\"><code>npm i stickpackage\n</code></pre><hr>\n<h2>配置介绍</h2>\n<ul>\n<li>[x] 提供对TCP粘包处理的解决方案</li>\n<li>[x] 默认缓冲512个字节，当接收数据超过512字节，自动以512倍数扩大缓冲空间</li>\n<li>[x] 本默认采用包头两个字节表示包长度</li>\n<li>[x] 默认采用大端接模式接收数据</li>\n<li>[x] 可以配置大端小端读取</li>\n<li>[x] 可以配置自定义包头长度</li>\n<li>[x] 支持自动拆解包</li>\n</ul>\n<hr>\n<h2>API</h2>\n<ul>\n<li>stick(bufferSize) =&gt; 直接处理字节类型的包</li>\n</ul>\n<pre class=\"prettyprint\"><code>    bufferSize:设置stick处理粘包的缓存空间\n</code></pre><ul>\n<li>stick.setReadIntBE(type) =&gt; 设置为大端模式&lt;依据数据包最大值选择合适type&gt;</li>\n</ul>\n<pre class=\"prettyprint\"><code>    setReadIntBE(type)  type:16  包头长度为2,short类型\n    setReadIntBE(type)  type:32  包头长度为4,int类型\n</code></pre><ul>\n<li>stick.setReadIntLE =&gt; 设置为小端模式&lt;依据数据包最大值选择合适type&gt;</li>\n</ul>\n<pre class=\"prettyprint\"><code>    setReadIntLE(type)  type:16  包头长度为2,short类型\n    setReadIntLE(type)  type:32  包头长度为4,int类型\n</code></pre><ul>\n<li>stick.putData(buffer) =&gt; 向stick中推送需要处理粘包的字节流</li>\n<li>stick.onData(buffer) =&gt; 监听stick解包好的一个个完整消息(包头+包体),用户自己的数据存储在包体中，如果不想处理包头用msgCenter已经封装好</li>\n<li>msgCenter(options) =&gt; 可直接发送字符串消息,基于stick封装，屏蔽stick层需要自己组装包头和拆包头的步骤</li>\n</ul>\n<pre class=\"prettyprint\"><code>    options.bufferSize: 设置用户处理粘包的缓存空间\n    options.type：设置包头为16位或者32位模式(16|32)\n    options.bigEndian: 设置大端、小端字节流模式,默认为打断模式,为false时为小端模式(true|false)\n</code></pre><ul>\n<li>msgCenter.putMsg(msg) =&gt; 向消息中心推送字符串消息</li>\n<li>msgCenter.publish(msg) =&gt; 发布一个消息,返回一个被打包好的buffer(包头+包体),用户clent发包时使用</li>\n</ul>\n<pre class=\"prettyprint\"><code>    msgCenter.publish(&#x27;123&#x27;) \n    =&gt; &lt;Buffer 00 03 31 32 33&gt; &#x2F;&#x2F; 00 03 包长度  31 32 33 字符串123的ascii码\n</code></pre><ul>\n<li>msgCenter.onMsgRecv(msgHandleFun) =&gt; 处理经过粘包处理后的消息</li>\n</ul>\n<pre class=\"prettyprint\"><code>    msgHandleFun:业务上处理消息的函数\n    msgCenter.onMsgRecv(msg =&gt; {\n        console.log(&#96;recv data: &#96; + msg.toString())\n        ...do something\n    })\n</code></pre><hr>\n<h2>更新记录:</h2>\n<ul>\n<li>设置大端,小端接收,添加setReadIntBE,添加setReadIntLE方法</li>\n<li>支持直接发送字符串消息,自动化组装包头</li>\n</ul>\n<hr>\n<h2>使用方法</h2>\n<ul>\n<li>服务端处理粘包</li>\n</ul>\n<pre class=\"prettyprint\"><code>    &#x2F;&#x2F; 默认client.js 采用 msgCenter.publish(&#x27;...&#x27;) 向服务端发消息\n    &#x2F;&#x2F; 以下是服务端收到消息后，进行粘包处理\n    const MsgCenter = require(&#x27;stickpackage&#x27;).msgCenter\n    const msgCenter = new MsgCenter()\n\n    &#x2F;&#x2F; server 监听分包后的消息\n    msgCenter.onMsgRecv(data =&gt; {\n        console.log(&#96;recv data: &#96; + data.toString())\n    })\n\n    &#x2F;&#x2F; 把 tcp server 监听到的字节流，put到msgCenter中\n    msgCenter.putData(Buffer.from([0x00, 0x02, 0x31, 0x32, 0x00, 0x04, 0x31, 0x32, 0x33, 0x34]))\n    &#x2F;&#x2F;=&gt; recv data: 12\n    &#x2F;&#x2F;=&gt; recv data: 1234\n\n</code></pre><hr>\n<ul>\n<li>发送二进制数据</li>\n</ul>\n<pre class=\"prettyprint\"><code>    &#x2F;&#x2F; 默认client.js 采用 stick 配置的组包式向服务器发送消息\n    &#x2F;&#x2F; 以下是服务端收到消息后，进行粘包处理\n\n    const Stick = require(&#x27;stickpackage&#x27;).stick;\n    const stick = new Stick(1024).setReadIntBE(&#x27;16&#x27;)\n\n    &#x2F;*\n    *  包含两个数据包,10个字节,包头为short，两个字节：[0x00, 0x02],[ 0x00, 0x04]\n    *  数据包1:[0x00, 0x02, 0x66, 0x66]\n    *  数据包2:[0x00, 0x04, 0x88, 0x02, 0x11, 0x11]\n    *&#x2F;\n    const data = Buffer.from([0x00, 0x02, 0x66, 0x66, 0x00, 0x04, 0x88, 0x02, 0x11, 0x11]);\n\n    &#x2F;*  构造两个buffer\n    *   data2_1包含:  第一个数据包的全部数据,第二个数据包的部分数据\t\n    *   data2_2包含:  第二个数据包的剩余数据\n    *&#x2F;\n    const data2_1 = Buffer.from([0x00, 0x00, 0x00, 0x02, 0x66, 0x66, 0x00, 0x04, 0x88, 0x02, 0x11]);\n    const data2_2 = Buffer.from([0x11]);\n\n    &#x2F;&#x2F; 设置收到完整数据触发器\n    stick.onData(function (data) {\n        console.log(&#x27;receive data,length:&#x27; + data.length);\n        console.log(data)\n    });\n\n    stick.putData(data);        \n    stick.putData(data2_1);\n    stick.putData(data2_2);  \n\n    &#x2F;&#x2F;  运行结果：   \n    &#x2F;&#x2F;  receive data,length:4 &lt;Buffer 00 02 66 66&gt;  \n    &#x2F;&#x2F;  receive data,length:6 &lt;Buffer 00 04 88 02 11 11&gt;\n    &#x2F;&#x2F;  receive data,length:2 &lt;Buffer 00 00&gt; receive data, length:4 &lt; Buffer 00 02 66 66&gt; receive data, length:6&lt; Buffer 00 04 88 02 11 11&gt;\n</code></pre><hr>\n<h2>案例演示</h2>\n<ul>\n<li>tcp client和tcp server 之间通过stick进行粘包处理通信,详细内容见example文件夹</li>\n<li>[tcp-msg]本demo主要演示TCP中处理粘包的方法，不需要自己组装包头，直接发送和接收文本消息，组包解包操作本类库已经封装在底层</li>\n</ul>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; Client.js\n    const net = require(&#x27;net&#x27;)\n    const stick = require(&#x27;..&#x2F;..&#x2F;index&#x27;)\n    const msgCenter = new stick.msgCenter()\n\n    const client = net.createConnection({ port: 8080, host: &#x27;127.0.0.1&#x27; }, function () {\n\n    const msgBuffer = msgCenter.publish(&#x27;username=123&amp;password=1234567,qwe&#x27;)\n\n    client.write(msgBuffer)\n\n})\n\n    client.on(&#x27;data&#x27;, function (data) {\n        console.log(data.toString())\n    })\n    client.on(&#x27;end&#x27;, function () {\n        console.log(&#x27;disconnect from server&#x27;)\n    })\n</code></pre><pre class=\"prettyprint\"><code>&#x2F;&#x2F; Server.js\n    const net = require(&#x27;net&#x27;)\n    const stick = require(&#x27;..&#x2F;..&#x2F;index&#x27;)\n\n    const tcp_server = net.createServer(function (socket) {\n        const msgCenter = new stick.msgCenter()\n\n        socket.on(&#x27;data&#x27;, function (data) {\n            msgCenter.putData(data)\n        })\n\n        msgCenter.onMsgRecv(function (data) {\n            console.log(&#x27;recv data: &#x27; + data.toString())\n        })\n\n        socket.on(&#x27;close&#x27;, function (error) {\n            console.log(&#x27;client disconnected&#x27;)\n        })\n\n        socket.on(&#x27;error&#x27;, function (error) {\n            console.log(&#96;error:客户端异常断开: ${error}&#96;)\n        })\n    })\n\n    tcp_server.on(&#x27;error&#x27;, function (err) {\n        throw err\n    })\n    tcp_server.listen(8080, function () {\n        console.log(&#x27;tcp_server listening on 8080&#x27;)\n    })\n</code></pre><ul>\n<li>[tcp-buffer]本demo主要演示TCP中直接处理字节流粘包，展示出如何自己组装包头包体和解包,如不向自己进行组装包头解包操作，请看demo tcp-msg</li>\n</ul>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; Clinet.js\n    const net = require(&#x27;net&#x27;)\n\n    const client = net.createConnection({ port: 8080, host: &#x27;127.0.0.1&#x27; }, function () {\n        const body = Buffer.from(&#x27;username=123&amp;password=1234567,qwe&#x27;)\n\n        &#x2F;&#x2F; 写入包头\n        const headBuf = new Buffer(4)\n        headBuf.writeUInt32BE(body.byteLength, 0)\n        console.log(&#x27;data length: &#x27; + headBuf.readInt32BE())\n\n        &#x2F;&#x2F; 发送包头\n        client.write(headBuf)\n        &#x2F;&#x2F; 发送包内容\n        client.write(body)\n        console.log(&#x27;data body: &#x27; + body.toString())\n\n    })\n\n    client.on(&#x27;data&#x27;, function (data) {\n        console.log(data.toString())\n    })\n    client.on(&#x27;end&#x27;, function () {\n        console.log(&#x27;disconnect from server&#x27;)\n    })\n</code></pre><pre class=\"prettyprint\"><code>&#x2F;&#x2F; Server.js\n    const net = require(&#x27;net&#x27;)\n    const stick_package = require(&#x27;..&#x2F;..&#x2F;index&#x27;).stick\n\n    const tcp_server = net.createServer(function (socket) {\n        socket.stick = new stick_package(1024).setReadIntBE(&#x27;32&#x27;)\n        socket.on(&#x27;data&#x27;, function (data) {\n            socket.stick.putData(data)\n        })\n\n        socket.stick.onData(function (data) {\n            &#x2F;&#x2F; 解析包头长度\n            const head = new Buffer(4)\n            data.copy(head, 0, 0, 4)\n\n            &#x2F;&#x2F; 解析数据包内容\n            const body = new Buffer(head.readInt32BE())\n            data.copy(body, 0, 4, head.readInt32BE())\n\n            console.log(&#x27;data length: &#x27; + head.readInt32BE())\n            console.log(&#x27;body content: &#x27; + body.toString())\n        })\n\n        socket.on(&#x27;close&#x27;, function (error) {\n            console.log(&#x27;client disconnected&#x27;)\n        })\n\n        socket.on(&#x27;error&#x27;, function (error) {\n            console.log(&#96;error:客户端异常断开: ${error}&#96;)\n        })\n    })\n\n    tcp_server.on(&#x27;error&#x27;, function (err) {\n        throw err\n    })\n    tcp_server.listen(8080, function () {\n        console.log(&#x27;tcp_server listening on 8080&#x27;)\n    })\n</code></pre><hr>\n<h2><a href=\"https://github.com/lvgithub/stickPackage.git\">源码地址，喜欢的话请点star，想订阅点watch</a></h2>\n</div>",
	"title": "tcp 粘包处理方案升级版(带TCP通信demo)",
	"last_reply_at": "2019-08-21T11:32:36.952Z",
	"good": false,
	"top": false,
	"reply_count": 21,
	"visit_count": 6920,
	"create_at": "2017-12-02T14:59:08.964Z",
	"author": {
		"loginname": "lvgithub",
		"avatar_url": "https://avatars1.githubusercontent.com/u/16065346?v=4&s=120"
	}
}, {
	"id": "5d5a723ed53e9171e98a92db",
	"author_id": "55c56e8a39273b9219336288",
	"tab": "share",
	"content": "<div class=\"markdown-text\"><p><img src=\"https://raw.githubusercontent.com/timqian/images/master/20190819131226.gif\" alt></p>\n<h2>如何食用</h2>\n<ul>\n<li>github 地址: <a href=\"http://github.com/timqian/chart.xkcd\">github.com/timqian/chart.xkcd</a></li>\n<li>正在写作中的文档: <a href=\"http://timqian.com/chart.xkcd\">timqian.com/chart.xkcd</a></li>\n<li>在 codepen 上试用\n<ul>\n<li><a href=\"https://codepen.io/timqian/pen/GRKqLaL\">line chart</a></li>\n<li><a href=\"https://codepen.io/timqian/pen/VwZjOPR\">pie chart</a></li>\n<li><a href=\"https://codepen.io/timqian/pen/QWLERdG\">bar chart</a></li>\n</ul>\n</li>\n</ul>\n<h2>为什么要做手绘风格的图表库</h2>\n<p>市面上已经有很多成熟的图表库了, chart.js, echart,… 都可以画出精美而准确的图表. 但有些时候, 我们不想图表看起来那么准确.</p>\n<p>比如我之前做的查看 github 项目 star 历史的工具 <a href=\"https://github.com/timqian/star-history\">star-history</a>. 某个时间点的 star 数其实没有意义, 我们想要了解的是项目的趋势. 对于这种图表, 手绘风格可能更加适合</p>\n<p>虽然已经花了 2 周多时间了, 但因为缺乏制作图表库方面的经验, 磕磕绊绊得做了三个常用图表, 也还存在者挺多已知和未知的 bug, 之后计划加入更多图表, 欢迎大家的试用和建议</p>\n</div>",
	"title": "做了一个 xkcd 风格 (手绘风格) 的图表库",
	"last_reply_at": "2019-08-21T11:29:30.308Z",
	"good": false,
	"top": false,
	"reply_count": 7,
	"visit_count": 567,
	"create_at": "2019-08-19T09:56:14.947Z",
	"author": {
		"loginname": "timqian",
		"avatar_url": "https://avatars3.githubusercontent.com/u/5512552?v=4&s=120"
	}
}, {
	"id": "57e17beac4ae8ff239776de5",
	"author_id": "57ddffa7b11d78e3659db597",
	"tab": "share",
	"content": "<div class=\"markdown-text\"><h3>关于axios在node中的post使用</h3>\n<h4>起因：</h4>\n<ul>\n<li>最近做的东西需要用到网络请求库，之前接触过的只有request，很强大好用。但是这个项目中需要用到Promise，我又不想重新封装，于是选择了另一款库axios。</li>\n<li>在node中，axios的get请求加上原生支持的Promise语法使用起来很方便，很丝滑，但是后面碰到了一个需求，就是要向另一个服务器post数据，并且这个数据是以form-data的形式post过去的，这时，问题就出现了。</li>\n</ul>\n<h4>问题：</h4>\n<ul>\n<li>当我想在node中使用axios以post的方式发送一张图片给某个server时，最先我是尝试这样做：<strong>方案一</strong></li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>\t\tlet data = fs.createReadStream(__dirname + &#x27;&#x2F;test.jpg&#x27;)\n\t\taxios.post(url,{media:data,type:&quot;image&quot;})\n\t\t.then(function (response) {\n\t\tconsole.log(response.data);\n\t\t})\n\t\t.catch(function (error) {\n\t\tconsole.log(error);\n\t\t})\n</code></pre><p>事实证明，这样做是完全没有用的，我尝试向另一个服务器poststream，返回的总是错误。然而，如果我使用request，下面这样的代码是完全没有问题的：<strong>方案二</strong></p>\n<pre class=\"prettyprint language-js\"><code>\t\tlet data = fs.createReadStream(__dirname + &#x27;&#x2F;test.jpg&#x27;)\n\t\tlet form = {\n\t\ttype:&quot;image&quot;,\n\t\tmedia:data\n\t\t}\n\t\t\n\t\trequest.post({url:url,formData:form},(err,res,body)=&gt;{\n\t\tif(err) console.log(err)\n\t\tconsole.log(body)\n\t\t})\n</code></pre><h4>探索：</h4>\n<ul>\n<li>于是，我陷入了思考，WTF！！\n<ul>\n<li>我打算简单的写一个服务器，用于打印HTTP请求，然后查看区别（别问我为什么不用抓包工具，任性！），代码呼之欲出：</li>\n</ul>\n<pre class=\"prettyprint language-javascript\"><code>\timport Koa from &#x27;koa&#x27;\n\n\tconst app = new Koa()\n\n\tapp.use(ctx=&gt;{\n\t\tconsole.log(&quot;===============================================&quot;)\n\t\tconsole.log(ctx.request)\n\t\tconsole.log(&quot;===============================================&quot;)\n\t\tctx.body = {foo:&quot;bar&quot;}\n\t})\n\n\tapp.listen(3000,()=&gt;{\n\t\tconsole.log(&quot;listening on 3000 port&quot;)\n\t})\n</code></pre><ul>\n<li>此时，将url设置为:<code>http://127.0.0.1:3000/</code>,再分别执行<strong>方案一</strong>和<strong>方案二</strong>\n这时打印出了这样的结果：</li>\n</ul>\n</li>\n</ul>\n<pre class=\"prettyprint\"><code>\t listening on 3000 port\n\t ===============================================\n\t { method: &#x27;POST&#x27;,\n\t url: &#x27;&#x2F;&#x27;,\n\t header: \n\t { accept: &#x27;application&#x2F;json, text&#x2F;plain, *&#x2F;*&#x27;,\n\t &#x27;content-type&#x27;: &#x27;application&#x2F;json;charset=utf-8&#x27;,\n\t &#x27;user-agent&#x27;: &#x27;axios&#x2F;0.14.0&#x27;,\n\t &#x27;content-length&#x27;: &#x27;587&#x27;,\n\t host: &#x27;127.0.0.1:3000&#x27;,\n\t connection: &#x27;close&#x27; } }\n\t ===============================================\n\t ===============================================\n\t { method: &#x27;POST&#x27;,\n\t url: &#x27;&#x2F;&#x27;,\n\t header: \n\t { host: &#x27;127.0.0.1:3000&#x27;,\n\t &#x27;content-type&#x27;: &#x27;multipart&#x2F;form-data; boundary=--------------------------949095406788084443059291&#x27;,\n\t &#x27;content-length&#x27;: &#x27;186610&#x27;,\n\t connection: &#x27;close&#x27; } }\n\t ===============================================\n</code></pre><pre class=\"prettyprint\"><code>- 上面的是方案一，下面的是方案二\n</code></pre><ul>\n<li>这时可以看出，方案一和二的差别最明显的是<code>content-type</code>,是的，这也是决定了方案一不可行的因素。\n既然是<code>content-type</code>导致的，那么方案一PLUS就比较明了了，查阅axios的文档后，我决定手动设置<code>content-type</code>，于是乎：</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>\t\tlet data = fs.createReadStream(__dirname + &#x27;&#x2F;test.jpg&#x27;)\n\t\tlet header = {\n\t\t\t&#x27;content-type&#x27;: &#x27;multipart&#x2F;form-data&#x27;\n\t\t}\n\t\taxios.post(url,{media:data,type:&quot;image&quot;},{headers:header})\n\t\t.then(function (response) {\n\t\t\tconsole.log(response.data);\n\t\t})\n\t\t.catch(function (error) {\n\t\t\tconsole.log(error);\n\t\t})\n</code></pre><pre class=\"prettyprint\"><code>- 这时，请求是这样的：\n</code></pre><pre class=\"prettyprint\"><code>    ===============================\n    { method: &#x27;POST&#x27;,\n      url: &#x27;&#x2F;&#x27;,\n      header: \n       { accept: &#x27;application&#x2F;json, text&#x2F;plain, *&#x2F;*&#x27;,\n         &#x27;content-type&#x27;: &#x27;multipart&#x2F;form-data&#x27;,\n         &#x27;user-agent&#x27;: &#x27;axios&#x2F;0.14.0&#x27;,\n         &#x27;content-length&#x27;: &#x27;587&#x27;,\n         host: &#x27;127.0.0.1:3000&#x27;,\n         connection: &#x27;close&#x27; } }\n    ================================\n</code></pre><p>貌似差别不大，但我先试着往服务器post数据时，仍然返回错误。实际上这时候没有<code>boundary</code>，文件其实并没有被绑定上去，所以现在仍然没有解决问题。至于boundary,这里有个<a href=\"http://stackoverflow.com/questions/3508338/what-is-the-boundary-in-multipart-form-data\">链接</a>非常能说明问题。</p>\n<ul>\n<li>到这里，我们就要耐下心来好好思考了，区别就在于，request中能够设置正确的请求头，那么它是怎么办到的呢，于是我开始翻看request的源码，发现了这一段：</li>\n</ul>\n<pre class=\"prettyprint language-javascript\"><code>\t\tif (options.formData) {\n\t\t\tvar formData = options.formData\n\t\t\tvar requestForm = self.form()\n\t\t\tvar appendFormValue = function (key, value) {\n\t\t\t  if (value &amp;&amp; value.hasOwnProperty(&#x27;value&#x27;) &amp;&amp; value.hasOwnProperty(&#x27;options&#x27;)) {\n\t\t\t\trequestForm.append(key, value.value, value.options)\n\t\t\t  } else {\n\t\t\t\trequestForm.append(key, value)\n\t\t\t  }\n\t\t\t}\n\t\t\tfor (var formKey in formData) {\n\t\t\t  if (formData.hasOwnProperty(formKey)) {\n\t\t\t\tvar formValue = formData[formKey]\n\t\t\t\tif (formValue instanceof Array) {\n\t\t\t\t  for (var j = 0; j &lt; formValue.length; j++) {\n\t\t\t\t\tappendFormValue(formKey, formValue[j])\n\t\t\t\t  }\n\t\t\t\t} else {\n\t\t\t\t  appendFormValue(formKey, formValue)\n\t\t\t\t}\n\t\t\t  }\n\t\t\t}\n\t\t  }\n</code></pre><p>这一段是request在初始化参数中的formData，其中调用了它自身的form()方法，追踪这个函数：</p>\n<pre class=\"prettyprint language-javascript\"><code>\t\tRequest.prototype.form = function (form) {\n\t\t  var self = this\n\t\t  if (form) {\n\t\t\tif (!&#x2F;^application\\&#x2F;x-www-form-urlencoded\\b&#x2F;.test(self.getHeader(&#x27;content-type&#x27;))) {\n\t\t\t  self.setHeader(&#x27;content-type&#x27;, &#x27;application&#x2F;x-www-form-urlencoded&#x27;)\n\t\t\t}\n\t\t\tself.body = (typeof form === &#x27;string&#x27;)\n\t\t\t  ? self._qs.rfc3986(form.toString(&#x27;utf8&#x27;))\n\t\t\t  : self._qs.stringify(form).toString(&#x27;utf8&#x27;)\n\t\t\treturn self\n\t\t  }\n\t\t  &#x2F;&#x2F; create form-data object\n\t\t  self._form = new FormData()\n\t\t  self._form.on(&#x27;error&#x27;, function(err) {\n\t\t\terr.message = &#x27;form-data: &#x27; + err.message\n\t\t\tself.emit(&#x27;error&#x27;, err)\n\t\t\tself.abort()\n\t\t  })\n\t\t  return self._form\n\t\t}\n</code></pre><p>发现了request调用了另一个库<code>form-data</code>，先通过self.form()创建出一个formData对象，再遍历options里的formData项，递归地将内容通过formData的append方法放进去，也就是说是formData实现了post文件，于是乎，我在axios中插入formData，形成了<strong>方案三</strong>：</p>\n<ul>\n<li>方案三：<pre class=\"prettyprint language-javascript\"><code>\tlet data = fs.createReadStream(__dirname + &#x27;&#x2F;test.jpg&#x27;)\n\tlet form = new FormData()\n\tform.append(&#x27;type&#x27;,&#x27;image&#x27;)\n\tform.append(&#x27;media&#x27;,data,&#x27;test.jpg&#x27;)\n\n\taxios.post(url,form).then((response)=&gt;{\n\t\tconsole.log(response.data)\n\t})\n\t.catch(e=&gt;{console.log(e)})\n</code></pre></li>\n</ul>\n<p>但是，事实告诉我，我还是悲剧了，请求打印出来是这样的：</p>\n<pre class=\"prettyprint\"><code>\t\t===============================================\n\t\t{ method: &#x27;POST&#x27;,\n\t\t  url: &#x27;&#x2F;&#x27;,\n\t\t  header: \n\t\t   { accept: &#x27;application&#x2F;json, text&#x2F;plain, *&#x2F;*&#x27;,\n\t\t\t &#x27;content-type&#x27;: &#x27;application&#x2F;x-www-form-urlencoded&#x27;,\n\t\t\t &#x27;user-agent&#x27;: &#x27;axios&#x2F;0.14.0&#x27;,\n\t\t\t host: &#x27;127.0.0.1:3000&#x27;,\n\t\t\t connection: &#x27;close&#x27;,\n\t\t\t &#x27;transfer-encoding&#x27;: &#x27;chunked&#x27; } }\n\t\t===============================================\n</code></pre><p>再次<code>content-type</code>还是不对，于是我再去翻axios的文档和issue，发现，默认设置的<code>content-type</code>就是<code>application/x-www-form-urlencoded</code>，于是我判断，一定还是要手动设置headers的</p>\n<ul>\n<li>于是，基于<strong>方案三</strong>，我又添加了和改动了这两行形成了<strong>方案四</strong>：<pre class=\"prettyprint language-javascript\"><code>\tlet header = {\n\t\t&#x27;content-type&#x27;: &#x27;multipart&#x2F;form-data&#x27;\n\t}\n\n\taxios.post(url,form,{headers:header}).then((response)=&gt;{\n\t\tconsole.log(response.data)\n\t})\n</code></pre></li>\n</ul>\n<p>但结果还是不理想，直接设置content-type是不行的，因为要将待发送文件绑定，就一定会有<code>boundary</code>出现，另外在<strong>方案三</strong>和<strong>方案四</strong>的请求中，出现了<code>transfer-encoding</code>这个值，关于这个<code>chunked</code>,可以参考<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Transfer-Encoding\">MDN</a>和这篇<a href=\"http://www.cnblogs.com/jcli/archive/2012/10/19/2730440.html\">博客</a></p>\n<ul>\n<li>一边google一边看文档的我，发现formData的文档中出现过form.getHeaders()的写法，于是<strong>方案五</strong>出现了：<pre class=\"prettyprint language-javascript\"><code>\tlet data = fs.createReadStream(__dirname + &#x27;&#x2F;test.jpg&#x27;)\n\tlet form = new FormData()\n\tform.append(&#x27;type&#x27;,&#x27;image&#x27;)\n\tform.append(&#x27;media&#x27;,data,&#x27;test.jpg&#x27;)\n\n\taxios.post(url,form,{headers:form.getHeaders()}).then((response)=&gt;{\n\t\tconsole.log(response.data)\n\t})\n\t.catch(e=&gt;{console.log(e)})\n</code></pre></li>\n</ul>\n<p>但是结果表明，这样还是不行，现在的请求是这样：</p>\n<pre class=\"prettyprint\"><code>\t\t===============================================\n\t\t{ method: &#x27;POST&#x27;,\n\t\t  url: &#x27;&#x2F;&#x27;,\n\t\t  header: \n\t\t   { accept: &#x27;application&#x2F;json, text&#x2F;plain, *&#x2F;*&#x27;,\n\t\t\t &#x27;content-type&#x27;: &#x27;multipart&#x2F;form-data; boundary=--------------------------171407872885673042671614&#x27;,\n\t\t\t &#x27;user-agent&#x27;: &#x27;axios&#x2F;0.14.0&#x27;,\n\t\t\t host: &#x27;127.0.0.1:3000&#x27;,\n\t\t\t connection: &#x27;close&#x27;,\n\t\t\t &#x27;transfer-encoding&#x27;: &#x27;chunked&#x27; } }\n\t\t===============================================\n</code></pre><p>但是我目前项目需求是，不使用<code>chunked</code>而采用<code>content-length</code>的方法来传输，这意味着，我要想办法搞到form的长度</p>\n<ul>\n<li>在成功案例中，使用requests，于是我翻看了部分源码：\n在<code>request/request.js</code>里出现了</li>\n</ul>\n<pre class=\"prettyprint language-javascript\"><code>\t\tfunction setContentLength () {\n\t\t\tif (isTypedArray(self.body)) {\n\t\t\t  self.body = new Buffer(self.body)\n\t\t\t}\n\t\t\n\t\t\tif (!self.hasHeader(&#x27;content-length&#x27;)) {\n\t\t\t  var length\n\t\t\t  if (typeof self.body === &#x27;string&#x27;) {\n\t\t\t\tlength = Buffer.byteLength(self.body)\n\t\t\t  }\n\t\t\t  else if (Array.isArray(self.body)) {\n\t\t\t\tlength = self.body.reduce(function (a, b) {return a + b.length}, 0)\n\t\t\t  }\n\t\t\t  else {\n\t\t\t\tlength = self.body.length\n\t\t\t  }\n\t\t\n\t\t\t  if (length) {\n\t\t\t\tself.setHeader(&#x27;content-length&#x27;, length)\n\t\t\t  } else {\n\t\t\t\tself.emit(&#x27;error&#x27;, new Error(&#x27;Argument error, options.body.&#x27;))\n\t\t\t  }\n\t\t\t}\n\t\t  }\n</code></pre><p>它采用Buffer来计算长度，然后添加到headers中去</p>\n<ul>\n<li>然后看看在axios里是如何做的：\n<code>axios/lib/adapters/http.js</code>里出现了</li>\n</ul>\n<pre class=\"prettyprint language-javascript\"><code>\t\tif (data &amp;&amp; !utils.isStream(data)) {\n\t\t\t  if (utils.isArrayBuffer(data)) {\n\t\t\t\tdata = new Buffer(new Uint8Array(data));\n\t\t\t  } else if (utils.isString(data)) {\n\t\t\t\tdata = new Buffer(data, &#x27;utf-8&#x27;);\n\t\t\t  } else {\n\t\t\t\treturn reject(createError(\n\t\t\t\t  &#x27;Data after transformation must be a string, an ArrayBuffer, or a Stream&#x27;,\n\t\t\t\t  config\n\t\t\t\t));\n\t\t\t  }\n\t\t\n\t\t\t  &#x2F;&#x2F; Add Content-Length header if data exists\n\t\t\t  headers[&#x27;Content-Length&#x27;] = data.length;\n\t\t\t}\n</code></pre><p>下文并没有出现else，所以，当data是stream的时候，并没有自动设置<code>content-length</code>\n所以，我需要在formData.getHeaders()后，再添加一个<code>content-length</code>的key</p>\n<ul>\n<li>想要计算长度，自然想到去看看源码，于是在<code>form-data/lib/form_data.js</code>中出现了惊喜:</li>\n</ul>\n<pre class=\"prettyprint language-javascript\"><code>\t\tFormData.prototype.getLength = function(cb) {\n\t\t  var knownLength = this._overheadLength + this._valueLength;\n\t\t\n\t\t  if (this._streams.length) {\n\t\t\tknownLength += this._lastBoundary().length;\n\t\t  }\n\t\t\n\t\t  if (!this._valuesToMeasure.length) {\n\t\t\tprocess.nextTick(cb.bind(this, null, knownLength));\n\t\t\treturn;\n\t\t  }\n\t\t\n\t\t  asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {\n\t\t\tif (err) {\n\t\t\t  cb(err);\n\t\t\t  return;\n\t\t\t}\n\t\t\n\t\t\tvalues.forEach(function(length) {\n\t\t\t  knownLength += length;\n\t\t\t});\n\t\t\n\t\t\tcb(null, knownLength);\n\t\t  });\n\t\t};\n</code></pre><p>formData已经封装好了得到长度的方法，只不过它是异步的，不过没关系，在实际项目中，可以将它手动Promise化。<strong>最终方案</strong>的代码也就自然出现了：</p>\n<ul>\n<li>方案六：</li>\n</ul>\n<pre class=\"prettyprint language-javascript\"><code>\t\tlet data = fs.createReadStream(__dirname + &#x27;&#x2F;test.jpg&#x27;)\n\t\tlet form = new FormData()\n\t\tform.append(&#x27;type&#x27;,&#x27;image&#x27;)\n\t\tform.append(&#x27;media&#x27;,data,&#x27;test.jpg&#x27;)\n\t\tform.getLength((err,length)=&gt;{\n\t\t\tif(err) console.log(err)\n\t\t\tlet headers = Object.assign({&#x27;Content-Length&#x27;:length},form.getHeaders())\n\t\t\taxios.post(url,form,{headers:headers}).then((response)=&gt;{\n\t\t\t\tconsole.log(response.data)\n\t\t\t})\n\t\t\t.catch(e=&gt;{console.log(e)})\n\t\t})\n</code></pre><p>这时的请求打印后是这样的：</p>\n<pre class=\"prettyprint\"><code>\t\t===============================================\n\t\t{ method: &#x27;POST&#x27;,\n\t\turl: &#x27;&#x2F;&#x27;,\n\t\theader: \n\t\t{ accept: &#x27;application&#x2F;json, text&#x2F;plain, *&#x2F;*&#x27;,\n\t\t&#x27;content-type&#x27;: &#x27;multipart&#x2F;form-data; boundary=--------------------------424584867554529984619649&#x27;,\n\t\t&#x27;content-length&#x27;: &#x27;186610&#x27;,\n\t\t&#x27;user-agent&#x27;: &#x27;axios&#x2F;0.14.0&#x27;,\n\t\thost: &#x27;127.0.0.1:3000&#x27;,\n\t\tconnection: &#x27;close&#x27; } }\n\t\t===============================================\n</code></pre><p>事实证明它是可以工作的。</p>\n<ul>\n<li>更进一步，我们把异步代码Promise一下,得到<strong>最终方案</strong>:<pre class=\"prettyprint language-javascript\"><code>\tlet data = fs.createReadStream(__dirname + &#x27;&#x2F;test.jpg&#x27;)\n\tlet form = new FormData()\n\tform.append(&#x27;type&#x27;,&#x27;image&#x27;)\n\tform.append(&#x27;media&#x27;,data,&#x27;test.jpg&#x27;)\n\n\tlet getHeaders = (form=&gt;{\n\t\treturn new Promise((resolve,reject)=&gt;{\n\t\t\tform.getLength((err,length)=&gt;{\n\t\t\t\tif(err) reject(err)\n\t\t\t\tlet headers = Object.assign({&#x27;Content-Length&#x27;:length},form.getHeaders())\n\t\t\t\tresolve(headers)\n\t\t\t})\n\t\t})\n\t})\n\n\tgetHeaders(form)\n\t.then(headers=&gt;{\n\t\treturn axios.post(url,form,{headers:headers})\n\t})\n\t.then((response)=&gt;{\n\t\tconsole.log(response.data)\n\t})\n\t.catch(e=&gt;{console.log(e)})\n</code></pre></li>\n</ul>\n<h4>最后：</h4>\n<p>得到一个结论，多多看issue，多多看源码，多多了解基础知识（HTTP协议），对于问题的解决十分重要。最后这一套的实验代码放在github上了，需要研究研究的同学们可以看看:<a href=\"https://github.com/chux0519/axios-request\">axios-request</a></p>\n</div>",
	"title": "关于axios在node中post的使用",
	"last_reply_at": "2019-08-21T10:38:24.937Z",
	"good": false,
	"top": false,
	"reply_count": 13,
	"visit_count": 47187,
	"create_at": "2016-09-20T18:11:54.404Z",
	"author": {
		"loginname": "chux0519",
		"avatar_url": "https://avatars1.githubusercontent.com/u/14276970?v=4&s=120"
	}
}, {
	"id": "5d5bc34012a01945444180c0",
	"author_id": "5d1c66a334bca667bc6e5023",
	"tab": "share",
	"content": "<div class=\"markdown-text\"><p>有兴趣的可以瞧瞧代码不多，这是部署在我自己云服务器上 <a href=\"http://down.ningto.com\">http://down.ningto.com</a>。<br>\n平时拷烤文件还是蛮方便的，当一个小网盘在使用。<br>\n我的服务器只有1M带宽所以大家就不要试速度了，可以自己部署试试在内网是非常快的。<br>\n由于博客是对外的所以禁用掉了删除和移动操作<br>\n效果图：\n<img src=\"//static.cnodejs.org/FtSJSUkgEvNTJVhfxnHjwu_bYPVr\" alt=\"node_file_mng.png\">\n启动</p>\n<pre class=\"prettyprint\"><code>npm start\n</code></pre><p>dev使用nodemon启动</p>\n<pre class=\"prettyprint\"><code>npm install -g  nodemon\nnpm run dev\n</code></pre><p>部署使用pm2</p>\n<pre class=\"prettyprint\"><code>npm install pm2 -g \nnpm run deploy\n</code></pre><h1>文件管理</h1>\n<p>通过浏览器很方便的对远程文件进行管理</p>\n<h2>Download 下载</h2>\n<p>点击文件可以直接下载，也可以勾选下载多个文件</p>\n<h2>Delete 删除</h2>\n<p>可以同时删除多个文件和目录</p>\n<h2>Move 移动</h2>\n<p>将文件，目录移动到其他目录或者更改名字</p>\n<h2>Archive 打包</h2>\n<p>可以将多个文件或目录压缩成一个zip格式的文件进行下载</p>\n<h2>Upload 上传</h2>\n<p>可以批量上传文件</p>\n<h2>New Folder 新建目录</h2>\n<p>新建目录</p>\n<h2>sort 排序</h2>\n<p>默认是升序，点击标题切换排序</p>\n<ul>\n<li>Default Sort：不排序，显示的顺序就是文件所在服务器目录下的顺序</li>\n<li>Type Sort：文件类型排序，文件或目录</li>\n<li>Name Sort：根据名字排序</li>\n<li>Size Sort：大小排序</li>\n<li>Time Sort：时间排序</li>\n</ul>\n<blockquote>\n<p>单个文件上传大小限制为1G</p>\n</blockquote>\n</div>",
	"title": "用nodejs写了个文件管理的网页",
	"last_reply_at": "2019-08-21T09:38:51.379Z",
	"good": false,
	"top": false,
	"reply_count": 1,
	"visit_count": 543,
	"create_at": "2019-08-20T09:54:08.906Z",
	"author": {
		"loginname": "tujiaw",
		"avatar_url": "https://avatars0.githubusercontent.com/u/5338512?v=4&s=120"
	}
}, {
	"id": "5d5d0935421846662d983bad",
	"author_id": "553f7f8b2bd4939b1e90557a",
	"tab": "ask",
	"content": "<div class=\"markdown-text\"><p>线上用的是 KOA 框架，但是最进发现有内存泄露的问题。</p>\n<p>利用 losf -p 1441  // 1441 node 的进程\n有大量如下的 无效 TCP连接</p>\n<pre class=\"prettyprint\"><code>node    1441 root  633u     sock                0,7      0t0 1303582007 protocol: TCP\nnode    1441 root  634u     sock                0,7      0t0 1304269214 protocol: TCP\nnode    1441 root  635u     sock                0,7      0t0 1303710205 protocol: TCP\nnode    1441 root  636u     sock                0,7      0t0 1303582123 protocol: TCP\nnode    1441 root  637u     sock                0,7      0t0 1303775234 protocol: TCP\nnode    1441 root  638u     sock                0,7      0t0 1303610276 protocol: TCP\nnode    1441 root  639u     sock                0,7      0t0 1303611228 protocol: TCP\nnode    1441 root  640u     sock                0,7      0t0 1304141344 protocol: TCP\nnode    1441 root  641u     sock                0,7      0t0 1303660211 protocol: TCP\nnode    1441 root  642u     sock                0,7      0t0 1303661306 protocol: TCP\nnode    1441 root  643u     sock                0,7      0t0 1303661321 protocol: TCP\nnode    1441 root  644u     sock                0,7      0t0 1304409789 protocol: TCP\nnode    1441 root  645u     sock                0,7      0t0 1303661359 protocol: TCP\nnode    1441 root  646u     sock                0,7      0t0 1303560180 protocol: TCP\n</code></pre><p>netstat -an | awk ‘/^tcp/ {++y[$NF]} END {for(w in y) print w, y[w]}’   // 该命令显示的连接情况是正常的</p>\n<pre class=\"prettyprint\"><code>LAST_ACK 73\nLISTEN 8\nSYN_RECV 11\nCLOSE_WAIT 8\nESTABLISHED 121\nFIN_WAIT2 16\nTIME_WAIT 73\n</code></pre><p>但是利用 ss -s 命令\n有大量closed 的连接  跟 losf 命令显示的数量级大概是一致的</p>\n<pre class=\"prettyprint\"><code>Total: 1079 (kernel 1102)\nTCP:   1061 (estab 121, closed 851, orphaned 74, synrecv 0, timewait 57&#x2F;0), ports 0\n\nTransport Total     IP        IPv6\n1102      -         -\nRAW\t  0         0         0\nUDP\t  3         2         1\nTCP\t  210       37        173\nINET\t  213       39        174\nFRAG\t  0         0         0\n</code></pre><p>有没有大佬知道什么原因？</p>\n</div>",
	"title": "Koa socket 泄露的问题",
	"last_reply_at": "2019-08-21T09:04:53.390Z",
	"good": false,
	"top": false,
	"reply_count": 0,
	"visit_count": 747,
	"create_at": "2019-08-21T09:04:53.390Z",
	"author": {
		"loginname": "ChangMM",
		"avatar_url": "https://avatars0.githubusercontent.com/u/10186775?v=4&s=120"
	}
}, {
	"id": "5d52864f12a0194544416542",
	"author_id": "57fef4a9fdf3bd3d6511858f",
	"tab": "ask",
	"content": "<div class=\"markdown-text\"><p>想用egg-socket.io实现一个对弈的房间，包括两个player，其余为观战者</p>\n<p>看文档房间是用 <a href=\"https://github.com/socketio/socket.io-redis\">socket.io-redis</a>实现的，好像只能通过nsp.adapter.clients获取到房间内所有users，而每个user没有角色属性</p>\n<p>如果想实现这个需求应该怎么做，小白请教</p>\n<p>我理解好像不对，redis里没有存数据？只是做消息订阅发布？\n那请问，房间的信息，用户id这些存哪了，源码没看懂</p>\n</div>",
	"title": "使用egg-socket.io实现房间如何自定义房间属性",
	"last_reply_at": "2019-08-21T07:41:17.940Z",
	"good": false,
	"top": false,
	"reply_count": 5,
	"visit_count": 785,
	"create_at": "2019-08-13T09:43:43.932Z",
	"author": {
		"loginname": "IEfucker",
		"avatar_url": "https://avatars0.githubusercontent.com/u/3446876?v=4&s=120"
	}
}]
